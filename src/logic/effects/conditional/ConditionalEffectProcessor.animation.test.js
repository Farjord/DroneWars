// ========================================
// CONDITIONAL EFFECT PROCESSOR - ANIMATION TESTS
// ========================================
// TDD: Tests verifying animation behavior for conditional effects
// Animations should only be generated when conditions are met

import { describe, it, expect, vi, beforeEach } from 'vitest';
import ConditionalEffectProcessor from './ConditionalEffectProcessor.js';

describe('Conditional Effects Animation Integration', () => {
  let processor;
  let mockTarget;
  let mockContext;
  let mockPlayerStates;
  let mockEffectResult;

  beforeEach(() => {
    processor = new ConditionalEffectProcessor();

    // Standard mock target drone
    mockTarget = {
      id: 'drone_123',
      name: 'TestDrone',
      hull: 3,
      currentShields: 2,
      isExhausted: false,
      isMarked: false,
      attack: 2,
      speed: 4,
      owner: 'player2',
      lane: 'lane1'
    };

    // Standard mock player states
    mockPlayerStates = {
      player1: {
        energy: 10,
        hand: [{ id: 'card1' }, { id: 'card2' }],
        deck: [{ id: 'card3' }, { id: 'card4' }],
        discard: [],
        dronesOnBoard: { lane1: [], lane2: [], lane3: [] },
        shipSections: { bridge: { hull: 10, allocatedShields: 5 } }
      },
      player2: {
        energy: 10,
        hand: [],
        deck: [],
        discard: [],
        dronesOnBoard: { lane1: [mockTarget], lane2: [], lane3: [] },
        shipSections: { bridge: { hull: 10, allocatedShields: 5 } }
      }
    };

    // Standard mock context
    mockContext = {
      target: mockTarget,
      actingPlayerId: 'player1',
      playerStates: mockPlayerStates,
      placedSections: {
        player1: ['bridge'],
        player2: ['bridge']
      },
      callbacks: { logCallback: vi.fn() },
      card: { id: 'CARD_TEST', name: 'Test Card' }
    };

    // Standard mock effect result for POST timing
    mockEffectResult = {
      wasDestroyed: false,
      damageDealt: { shield: 0, hull: 0 },
      targetId: 'drone_123'
    };
  });

  // ========================================
  // PRE TIMING ANIMATIONS
  // ========================================
  describe('PRE timing animations', () => {
    it('generates NO animation for BONUS_DAMAGE (modifies primary, not separate)', () => {
      mockTarget.isMarked = true;
      const primaryEffect = { type: 'DAMAGE', value: 2 };
      const conditionalEffects = [{
        id: 'marked-bonus',
        timing: 'PRE',
        condition: { type: 'TARGET_IS_MARKED' },
        grantedEffect: { type: 'BONUS_DAMAGE', value: 2 }
      }];

      const result = processor.processPreConditionals(conditionalEffects, primaryEffect, mockContext);

      // BONUS_DAMAGE modifies the primary effect, not a separate animation
      expect(result.animationEvents).toEqual([]);
    });

    it('generates NO animation when PRE condition NOT met', () => {
      mockTarget.isMarked = false; // Condition NOT met
      const primaryEffect = { type: 'DAMAGE', value: 2 };
      const conditionalEffects = [{
        id: 'marked-bonus',
        timing: 'PRE',
        condition: { type: 'TARGET_IS_MARKED' },
        grantedEffect: { type: 'BONUS_DAMAGE', value: 2 }
      }];

      const result = processor.processPreConditionals(conditionalEffects, primaryEffect, mockContext);

      expect(result.animationEvents).toEqual([]);
    });

    it('queues DESTROY effect (which will generate animation when routed)', () => {
      mockTarget.hull = 1;
      const primaryEffect = null;
      const conditionalEffects = [{
        id: 'execute-weak',
        timing: 'PRE',
        condition: { type: 'TARGET_STAT_LT', stat: 'hull', value: 2 },
        grantedEffect: { type: 'DESTROY', scope: 'SINGLE' }
      }];

      const result = processor.processPreConditionals(conditionalEffects, primaryEffect, mockContext);

      // ConditionalEffectProcessor queues the DESTROY effect as additionalEffects
      // The animation is generated by DestroyEffectProcessor when routed
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'DESTROY' })
      );
      // The processor itself doesn't generate animations - they come from the routed effect
      expect(result.animationEvents).toEqual([]);
    });
  });

  // ========================================
  // POST TIMING ANIMATIONS
  // ========================================
  describe('POST timing animations', () => {
    it('generates NO animation for DRAW (state-only effect)', () => {
      mockEffectResult.wasDestroyed = true;
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [{
        id: 'draw-on-destroy',
        timing: 'POST',
        condition: { type: 'ON_DESTROY' },
        grantedEffect: { type: 'DRAW', value: 1 }
      }];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // DRAW is state-only, queued as additionalEffect for later processing
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'DRAW' })
      );
      // No animation from the conditional processor
      expect(result.animationEvents).toEqual([]);
    });

    it('generates NO animation for GAIN_ENERGY (state-only effect)', () => {
      mockEffectResult.damageDealt = { shield: 1, hull: 2 };
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [{
        id: 'energy-on-hull-damage',
        timing: 'POST',
        condition: { type: 'ON_HULL_DAMAGE' },
        grantedEffect: { type: 'GAIN_ENERGY', value: 2 }
      }];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // GAIN_ENERGY is state-only
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'GAIN_ENERGY' })
      );
      expect(result.animationEvents).toEqual([]);
    });

    it('generates NO animation for GO_AGAIN (flag only)', () => {
      mockEffectResult.wasDestroyed = true;
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [{
        id: 'goagain-on-destroy',
        timing: 'POST',
        condition: { type: 'ON_DESTROY' },
        grantedEffect: { type: 'GO_AGAIN' }
      }];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // GO_AGAIN is a flag, not queued as effect
      expect(result.grantsGoAgain).toBe(true);
      expect(result.animationEvents).toEqual([]);
    });

    it('generates NO animation when POST condition NOT met', () => {
      mockEffectResult.wasDestroyed = false; // Condition NOT met
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [{
        id: 'draw-on-destroy',
        timing: 'POST',
        condition: { type: 'ON_DESTROY' },
        grantedEffect: { type: 'DRAW', value: 1 }
      }];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // No effect queued, no animation
      expect(result.additionalEffects).toEqual([]);
      expect(result.animationEvents).toEqual([]);
    });
  });

  // ========================================
  // GRANTED EFFECTS ROUTING PATTERN
  // ========================================
  describe('granted effects routing pattern', () => {
    it('queues HEAL_HULL as additionalEffect (animation via HealEffectProcessor)', () => {
      mockEffectResult.wasDestroyed = true;
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [{
        id: 'heal-on-kill',
        timing: 'POST',
        condition: { type: 'ON_DESTROY' },
        grantedEffect: { type: 'HEAL_HULL', value: 2 }
      }];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // HEAL_HULL is queued for later routing through EffectRouter
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'HEAL_HULL', value: 2 })
      );
      // Animation will be generated by HealEffectProcessor when routed
      expect(result.animationEvents).toEqual([]);
    });

    it('queues multiple effects independently when conditions met', () => {
      mockEffectResult.wasDestroyed = true;
      mockEffectResult.damageDealt = { shield: 1, hull: 2 };
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [
        {
          id: 'draw-on-destroy',
          timing: 'POST',
          condition: { type: 'ON_DESTROY' },
          grantedEffect: { type: 'DRAW', value: 1 }
        },
        {
          id: 'energy-on-hull-damage',
          timing: 'POST',
          condition: { type: 'ON_HULL_DAMAGE' },
          grantedEffect: { type: 'GAIN_ENERGY', value: 2 }
        }
      ];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // Both effects queued (hull: 2 > 0, wasDestroyed: true)
      expect(result.additionalEffects).toHaveLength(2);
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'DRAW' })
      );
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'GAIN_ENERGY' })
      );
    });

    it('queues only effects with met conditions', () => {
      mockEffectResult.wasDestroyed = false; // ON_DESTROY NOT met
      mockEffectResult.damageDealt = { shield: 1, hull: 2 }; // ON_HULL_DAMAGE met (hull > 0)
      mockContext.effectResult = mockEffectResult;
      const conditionalEffects = [
        {
          id: 'draw-on-destroy',
          timing: 'POST',
          condition: { type: 'ON_DESTROY' },
          grantedEffect: { type: 'DRAW', value: 1 }
        },
        {
          id: 'energy-on-hull-damage',
          timing: 'POST',
          condition: { type: 'ON_HULL_DAMAGE' },
          grantedEffect: { type: 'GAIN_ENERGY', value: 2 }
        }
      ];

      const result = processor.processPostConditionals(conditionalEffects, mockContext, mockEffectResult);

      // Only ON_HULL_DAMAGE effect queued (hull: 2 > 0)
      expect(result.additionalEffects).toHaveLength(1);
      expect(result.additionalEffects).toContainEqual(
        expect.objectContaining({ type: 'GAIN_ENERGY' })
      );
      expect(result.additionalEffects).not.toContainEqual(
        expect.objectContaining({ type: 'DRAW' })
      );
    });
  });
});
