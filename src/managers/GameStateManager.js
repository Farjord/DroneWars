// ========================================
// GAME STATE MANAGER
// ========================================
// Centralized game state management for multiplayer support.
// Separates core game state from UI state and provides event-driven updates.

import { gameEngine, startingDecklist } from '../logic/gameLogic.js';
import ActionProcessor from './ActionProcessor.js';
import GameDataService from '../services/GameDataService.js';
import { debugLog } from '../utils/debugLogger.js';
import aiPhaseProcessor from './AIPhaseProcessor.js';
import tacticalMapStateManager from './TacticalMapStateManager.js';
import StateValidationService from '../logic/state/StateValidationService.js';
import GuestSyncManager from './GuestSyncManager.js';
import SinglePlayerInventoryManager from './SinglePlayerInventoryManager.js';
import TacticalItemManager from './TacticalItemManager.js';
import ShipSlotManager from './ShipSlotManager.js';
import RunLifecycleManager from './RunLifecycleManager.js';

class GameStateManager {
  constructor() {
    debugLog('STATE_SYNC', 'ðŸ”„ GAMESTATE INITIALIZATION: Creating new GameStateManager instance');

    // Event listeners for state changes
    this.listeners = new Set();

    // State validation service (extracted â€” validates state updates, phase transitions, ownership)
    this.stateValidationService = new StateValidationService(this);

    // Core application state (minimal until game starts)
    this.state = {
      // --- APPLICATION STATE ---
      appState: 'menu', // 'menu', 'inGame', 'gameOver'

      // --- MULTIPLAYER STATE ---
      isConnected: false,
      opponentId: null,
      gameMode: 'local', // 'local', 'host', 'guest'

      // --- TESTING MODE ---
      testMode: false, // Indicates if this is a test game (bypasses normal flow)

      // --- GAME STATE (null until game starts) ---
      gameActive: false,
      gameSeed: null, // Random seed for deterministic gameplay (generated by Host/Local, received by Guest)
      turnPhase: null,
      turn: null,
      currentPlayer: null,
      actionsTakenThisTurn: 0,  // Track actions for NOT_FIRST_ACTION ability condition
      firstPlayerOfRound: null,
      firstPasserOfPreviousRound: null,
      firstPlayerOverride: null,
      passInfo: null,
      winner: null,
      player1: null,
      player2: null,
      placedSections: [],
      opponentPlacedSections: [],
      unplacedSections: [],
      shieldsToAllocate: 0,
      droneSelectionPool: [],
      droneSelectionTrio: [],
      gameLog: [],
      aiDecisionHistory: [], // Array of AI decision entries for CSV export

      // --- GAME FLOW METADATA (owned by GameFlowManager) ---
      gameStage: 'preGame', // 'preGame', 'roundLoop', 'gameOver'
      roundNumber: 0,

      // --- COMMITMENTS (for simultaneous phases) ---
      commitments: {},

      // --- SINGLE-PLAYER STATE (Extraction Mode) ---
      singlePlayerProfile: null,         // Player profile data
      singlePlayerInventory: {},         // Card inventory (master quantities)
      singlePlayerDroneInstances: [],    // Drone instances with damage tracking
      singlePlayerShipComponentInstances: [],  // Ship component instances with hull tracking
      singlePlayerDiscoveredCards: [],   // Card discovery states (owned/discovered/undiscovered)
      singlePlayerShipSlots: [],         // 6 ship slots
      quickDeployments: [],              // Quick deploy templates (max 5)

      // --- EXTRACTION DECK BUILDER NAVIGATION ---
      extractionDeckSlotId: null,        // Slot ID being edited (0-5) or null
      extractionNewDeckOption: null,     // 'empty' | 'copyFromSlot0' | null

      // --- FAILED RUN LOADING SCREEN ---
      showFailedRunScreen: false,        // Show failed run transition screen
      failedRunType: null,               // 'combat' | 'detection' | 'abandon'
      failedRunIsStarterDeck: false,     // If true, show "RUN FAILED" instead of "SHIP MARKED MIA"
    };

    // Initialize action processor using singleton pattern
    // PhaseAnimationQueue will be injected later in AppRouter
    this.actionProcessor = ActionProcessor.getInstance(this, null);

    // Game flow manager reference (set during initialization)
    this.gameFlowManager = null;

    // Guest sync manager (extracted â€” handles P2P integration, optimistic actions, host state)
    this.guestSyncManager = new GuestSyncManager(this);

    // Single-player inventory manager (extracted â€” save/load, inventory, card discovery, ship components)
    this.singlePlayerInventoryManager = new SinglePlayerInventoryManager(this);

    // Tactical item manager (extracted â€” item purchase/use, card pack shop)
    this.tacticalItemManager = new TacticalItemManager(this);

    // Ship slot manager (extracted â€” deck CRUD, repair, drone/component instances)
    this.shipSlotManager = new ShipSlotManager(this);

    // Run lifecycle manager (extracted â€” startRun/endRun orchestration)
    this.runLifecycleManager = new RunLifecycleManager(this);

    // Context flag for production-safe validation (avoids minification breaking stack traces)
    this._updateContext = null;

    // Log initial application state
    debugLog('STATE_SYNC', 'ðŸ”„ GAMESTATE INITIALIZATION: GameStateManager created');
    debugLog('STATE_SYNC', 'ðŸ“± App State:', this.state.appState);
    debugLog('STATE_SYNC', 'ðŸŽ® Game Active:', this.state.gameActive);
    debugLog('STATE_SYNC', 'âœ… GAMESTATE INITIALIZATION: GameStateManager ready (no game active)');
  }

  // --- MANAGER REFERENCES ---

  /**
   * Set the GameFlowManager reference
   * @param {Object} gameFlowManager - GameFlowManager instance
   */
  setGameFlowManager(gameFlowManager) {
    this.gameFlowManager = gameFlowManager;
  }

  // --- GUEST SYNC FACADES ---
  // GFM and GMQS access these via this.gameStateManager â€” thin delegation to guestSyncManager
  // TODO: Remove facades when GFM/GMQS are updated to receive guestSyncManager directly

  setupP2PIntegration(p2pManager) { this.guestSyncManager.setupP2PIntegration(p2pManager); }
  startValidation(targetPhase, guestState) { this.guestSyncManager.startValidation(targetPhase, guestState); }
  shouldValidateBroadcast(incomingPhase) { return this.guestSyncManager.shouldValidateBroadcast(incomingPhase); }
  isMilestonePhase(phase) { return this.guestSyncManager.isMilestonePhase(phase); }
  applyHostState(hostState) { this.guestSyncManager.applyHostState(hostState); }
  trackOptimisticAnimations(animations) { this.guestSyncManager.trackOptimisticAnimations(animations); }
  filterAnimations(actionAnimations, systemAnimations) { return this.guestSyncManager.filterAnimations(actionAnimations, systemAnimations); }
  hasRecentOptimisticActions() { return this.guestSyncManager.hasRecentOptimisticActions(); }
  clearOptimisticActions() { this.guestSyncManager.clearOptimisticActions(); }

  // Property proxies â€” external code accesses these directly on GSM
  get optimisticActionService() { return this.guestSyncManager.optimisticActionService; }
  get validatingState() { return this.guestSyncManager.validatingState; }
  set validatingState(value) { this.guestSyncManager.validatingState = value; }

  // --- EVENT SYSTEM ---

  /**
   * Subscribe to state changes
   * @param {Function} listener - Callback function called when state changes
   * @returns {Function} Unsubscribe function
   */
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Notify all listeners of state change
   * @param {string} type - Type of change
   * @param {Object} payload - Additional data
   */
  emit(type, payload = {}) {
    this.listeners.forEach(listener => {
      try {
        listener({ type, payload, state: this.getState() });
      } catch (error) {
        debugLog('STATE_SYNC', 'ðŸš¨ Error in state listener', { error });
      }
    });
  }

  // --- STATE ACCESS ---

  /**
   * Get current state (read-only)
   */
  getState() {
    return { ...this.state };
  }

  /**
   * Get specific state property
   */
  get(key) {
    return this.state[key];
  }

  /**
   * Update state and notify listeners
   * @param {Object} updates - State updates to apply
   * @param {string} eventType - Type of event for logging
   * @param {string} context - Context of the update for validation (e.g., 'phaseTransition')
   */
  setState(updates, eventType = 'STATE_UPDATE', context = null) {
    const prevState = { ...this.state };

    // CRITICAL: Log appState transitions for extraction mode debugging
    if (updates.appState && updates.appState !== this.state.appState) {
      debugLog('EXTRACTION', 'appState transition', {
        from: this.state.appState,
        to: updates.appState,
        hasRunState: tacticalMapStateManager.isRunActive(),
        runAbandoning: this.state.runAbandoning,
        eventType
      });
    }

    // Extract caller information from stack trace for detailed logging
    const stack = new Error().stack;
    const stackLines = stack ? stack.split('\n') : [];
    const callerInfo = this.stateValidationService.extractCallerInfo(stackLines);

    // Check for architecture violations - App.jsx should NEVER directly update GameStateManager
    // However, App.jsx can call ActionProcessor/PhaseManager/ExtractionController which then update GameStateManager
    const isAppJsxCaller = stackLines.some(line => line.includes('App.jsx'));
    const isViaActionProcessor = stackLines.some(line => line.includes('ActionProcessor'));
    const isViaPhaseManager = stackLines.some(line => line.includes('PhaseManager'));
    const isViaExtractionController = stackLines.some(line => line.includes('ExtractionController'));
    const isLegitimateCall = isViaActionProcessor || isViaPhaseManager || isViaExtractionController;

    if (isAppJsxCaller && !isLegitimateCall) {
      debugLog('VALIDATION', 'ðŸš¨ ARCHITECTURE VIOLATION: App.jsx is directly updating GameStateManager!', {
        recommendation: 'App.jsx should only call ActionProcessor, PhaseManager, or ExtractionController methods',
        stack
      });
    }

    // Comprehensive state change logging
    const updateKeys = Object.keys(updates);
    const caller = `${callerInfo.primaryCaller} in ${callerInfo.primaryFile}`;

    debugLog('STATE_SYNC', `ðŸ” GAMESTATE CHANGE [${eventType}] from ${caller}:`, {
      changedKeys: updateKeys,
      allUpdates: updates,
      architectureViolation: isAppJsxCaller && !isLegitimateCall
    });

    // Special detailed logging for player state changes (skip during initialization)
    const isInitializationEvent = ['GAME_RESET', 'INITIALIZATION'].includes(eventType);
    if ((updates.player1 || updates.player2) && !isInitializationEvent) {
      this.stateValidationService.logPlayerStateChanges(updates, prevState, caller, eventType);
    }

    // Log other critical state changes
    updateKeys.forEach(key => {
      if (!['player1', 'player2'].includes(key)) {
        const oldValue = prevState[key];
        const newValue = updates[key];
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
          debugLog('STATE_SYNC', `ðŸ” STATE CHANGE: ${key}`, {
            before: oldValue,
            after: newValue,
            caller: caller,
            eventType: eventType
          });
        }
      }
    });

    // Validate state consistency before update
    this.stateValidationService.validateStateUpdate(updates, prevState, context);

    this.state = { ...this.state, ...updates };
    this.emit(eventType, { updates, prevState });
  }

  // --- GAME STATE METHODS ---

  /**
   * Validate that game state is clean before starting a new game
   * @returns {{ valid: boolean, issues: string[] }} Validation result
   */
  validatePreGameState() {
    const issues = [];

    if (this.state.gameStage !== 'preGame') {
      issues.push(`gameStage is '${this.state.gameStage}' (expected 'preGame')`);
    }
    if (this.state.roundNumber !== 0) {
      issues.push(`roundNumber is ${this.state.roundNumber} (expected 0)`);
    }
    if (this.state.gameActive) {
      issues.push('gameActive is true (expected false)');
    }
    if (this.state.player1 !== null) {
      issues.push('player1 is not null');
    }
    if (this.state.player2 !== null) {
      issues.push('player2 is not null');
    }
    if (this.state.turnPhase !== null) {
      issues.push(`turnPhase is '${this.state.turnPhase}' (expected null)`);
    }
    if (tacticalMapStateManager.isRunActive()) {
      issues.push('TacticalMapStateManager has active run (orphaned single-player run)');
    }
    if (this.state.singlePlayerEncounter !== null) {
      issues.push('singlePlayerEncounter is not null');
    }
    if (this.state.winner !== null) {
      issues.push(`winner is '${this.state.winner}' (expected null)`);
    }
    if (this.state.commitments && Object.keys(this.state.commitments).length > 0) {
      issues.push('commitments object is not empty');
    }

    if (issues.length > 0) {
      debugLog('STATE_SYNC', 'âš ï¸ Pre-game state validation failed:', issues);
      return { valid: false, issues };
    }
    return { valid: true, issues: [] };
  }

  /**
   * Validate that state is clean before starting a single-player run
   * @returns {{ valid: boolean, issues: string[] }} Validation result
   */
  validatePreRunState() {
    const issues = [];

    if (tacticalMapStateManager.isRunActive()) {
      issues.push('TacticalMapStateManager has active run (run already in progress)');
    }
    if (this.state.singlePlayerEncounter !== null) {
      issues.push('singlePlayerEncounter is not null');
    }
    if (this.state.gameActive) {
      issues.push('gameActive is true (PvP game in progress)');
    }

    if (issues.length > 0) {
      debugLog('STATE_SYNC', 'âš ï¸ Pre-run state validation failed:', issues);
      return { valid: false, issues };
    }
    return { valid: true, issues: [] };
  }

  /**
   * Clear single-player context (run state and encounter) without clearing profile/inventory
   * Call this before starting PvP games to clean up orphaned SP state
   */
  clearSinglePlayerContext() {
    debugLog('STATE_SYNC', 'ðŸ§¹ Clearing single-player context');
    // End run in TacticalMapStateManager if active
    if (tacticalMapStateManager.isRunActive()) {
      tacticalMapStateManager.endRun();
    }
    this.setState({
      singlePlayerEncounter: null
    });
  }

  /**
   * Safely transition to a new app state with automatic cleanup
   * @param {string} newState - The new app state to transition to
   */
  transitionToAppState(newState) {
    // Clean up active game if navigating away to menu
    if (this.state.gameActive && newState === 'menu') {
      debugLog('STATE_SYNC', 'Active game detected during navigation, cleaning up');
      this.endGame();
    }

    // Clean up run state if navigating to menu
    if (tacticalMapStateManager.isRunActive() && newState === 'menu') {
      debugLog('STATE_SYNC', 'Active run detected during navigation, cleaning up');
      this.endRun(false); // Lost run
    }

    this.setState({ appState: newState });
  }

  /**
   * Reset game to initial state
   */
  reset() {
    debugLog('STATE_SYNC', 'ðŸ”„ GAME RESET: Resetting game state and clearing caches');

    const initialState = {
      turnPhase: 'preGame',
      turn: 1,
      currentPlayer: null,
      actionsTakenThisTurn: 0,
      firstPlayerOfRound: null,
      firstPasserOfPreviousRound: null,
      firstPlayerOverride: null,
      passInfo: { firstPasser: null, player1Passed: false, player2Passed: false },
      winner: null,
      player1: gameEngine.initialPlayerState('Player 1', startingDecklist),
      player2: gameEngine.initialPlayerState('Player 2', startingDecklist),
      placedSections: [],
      opponentPlacedSections: [],
      unplacedSections: [],
      shieldsToAllocate: 0,
      droneSelectionPool: [],
      droneSelectionTrio: [],
      gameLog: [],

      // --- COMMITMENTS (for simultaneous phases) ---
      commitments: {},
    };

    this.setState(initialState, 'GAME_RESET');

    // Clear GameDataService singleton and cache to prevent stale data
    GameDataService.reset();

    // Clear ActionProcessor queue to prevent stale actions
    this.actionProcessor.clearQueue();
    // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
    this.gameFlowManager?.resubscribe();

    debugLog('STATE_SYNC', 'âœ… GAME RESET: State, cache, and queue cleared');
  }

  /**
   * Start a new game session - initialize players and game state
   * @param {string} gameMode - 'local', 'host', 'guest'
   * @param {Object} player1Config - Player 1 configuration
   * @param {Object} player2Config - Player 2 configuration
   */
  startGame(gameMode = 'local', player1Config = {}, player2Config = {}) {
    debugLog('STATE_SYNC', 'ðŸŽ® GAME START: Initializing new game session');

    // Clear any orphaned single-player context before starting PvP
    this.clearSinglePlayerContext();

    // Validate pre-game state and cleanup if dirty
    const validation = this.validatePreGameState();
    if (!validation.valid) {
      debugLog('VALIDATION', 'ðŸš¨ DIRTY STATE DETECTED AT GAME START', {
        issues: validation.issues,
        action: 'Calling resetGameState() to clean up',
        stack: new Error().stack
      });
      this.resetGameState();
    }

    // Generate random game seed for deterministic gameplay
    // Host/Local generates, Guest receives from first broadcast
    const gameSeed = gameMode === 'guest'
      ? null  // Guest will receive seed from Host
      : Math.floor(Math.random() * 2147483647);

    const gameState = {
      // Activate game
      appState: 'inGame',
      gameActive: true,
      gameMode: gameMode,
      gameSeed: gameSeed,

      // Initialize game flow
      turnPhase: 'deckSelection',
      turn: 1,
      gameStage: 'preGame',
      roundNumber: 0,
      currentPlayer: null,
      actionsTakenThisTurn: 0,
      firstPlayerOfRound: null,
      firstPasserOfPreviousRound: null,
      firstPlayerOverride: null,
      passInfo: { firstPasser: null, player1Passed: false, player2Passed: false },
      winner: null,

      // Initialize players with custom configurations
      player1: {
        ...gameEngine.initialPlayerState(
          player1Config.name || 'Player 1',
          player1Config.decklist || startingDecklist,
          'player1',
          gameSeed,  // Use same seed for both players
          player1Config.shipId || null  // Ship card ID (null = default)
        ),
        ...player1Config
      },
      player2: {
        ...gameEngine.initialPlayerState(
          player2Config.name || 'Player 2',
          player2Config.decklist || startingDecklist,
          'player2',
          gameSeed,  // Use same seed for both players
          player2Config.shipId || null  // Ship card ID (null = default)
        ),
        ...player2Config
      },

      // Initialize game components
      placedSections: [],
      opponentPlacedSections: [],
      unplacedSections: [],
      shieldsToAllocate: 0,
      gameLog: [],

      // --- COMMITMENTS (for simultaneous phases) ---
      commitments: {},

      // Drone selection data (will be initialized by GameFlowManager when transitioning to droneSelection)
      droneSelectionPool: [],
      droneSelectionTrio: [],
    };

    this.setState(gameState, 'GAME_STARTED');

    // Set up GameFlowManager subscription just before gameplay begins
    // This is the "just-in-time" initialization point for turn transitions
    // See: GameFlowManager.subscription.test.js for architectural documentation
    this.gameFlowManager?.resubscribe();

    debugLog('STATE_SYNC', 'ðŸ‘¤ Player 1 Created:', {
      name: gameState.player1.name,
      energy: gameState.player1.energy,
      deckCount: gameState.player1.deck?.length || 0
    });
    debugLog('STATE_SYNC', 'ðŸ‘¤ Player 2 Created:', {
      name: gameState.player2.name,
      energy: gameState.player2.energy,
      deckCount: gameState.player2.deck?.length || 0
    });
    debugLog('STATE_SYNC', 'âœ… GAME START: Game session initialized successfully');
  }

  /**
   * End current game session - return to menu state
   */
  endGame() {
    debugLog('STATE_SYNC', 'ðŸŽ® GAME END: Ending current game session and clearing caches');

    // Use canonical reset function for all game state cleanup
    this.resetGameState();

    // Set app state to menu (not part of game state reset)
    this.setState({
      appState: 'menu',
    }, 'GAME_ENDED');

    // Clear GameDataService singleton and cache to prevent stale data in new games
    GameDataService.reset();

    // Clear ActionProcessor queue to prevent stale actions
    this.actionProcessor.clearQueue();
    // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
    this.gameFlowManager?.resubscribe();

    // Reset GameFlowManager to clear phase state (includes PhaseManager.reset())
    if (this.gameFlowManager) {
      this.gameFlowManager.reset();
    }

    // Clean up AIPhaseProcessor (clear timers, unsubscribe from state changes)
    // This prevents stale subscriptions and timers from affecting the next game
    if (aiPhaseProcessor?.cleanup) {
      aiPhaseProcessor.cleanup();
      debugLog('STATE_SYNC', 'âœ… AIPhaseProcessor cleaned up');
    }

    debugLog('STATE_SYNC', 'âœ… GAME END: Returned to menu state, all singletons cleared');
  }

  /**
   * Initialize test mode game - bypasses normal game flow
   * @param {Object} testConfig - Test configuration from testGameInitializer
   * @returns {boolean} Success status
   */
  initializeTestMode(testConfig) {
    debugLog('STATE_SYNC', 'ðŸ§ª TEST MODE: Initializing test game from GameStateManager');

    // Import testGameInitializer dynamically to avoid circular dependencies
    import('../services/testGameInitializer.js').then(module => {
      const success = module.initializeTestGame(testConfig, this);

      if (success) {
        debugLog('STATE_SYNC', 'âœ… TEST MODE: Test game initialized successfully');
      } else {
        debugLog('STATE_SYNC', 'âŒ TEST MODE: Test game initialization failed');
      }
    }).catch(error => {
      debugLog('STATE_SYNC', 'ðŸš¨ TEST MODE: Error importing testGameInitializer', { error });
    });

    return true; // Return immediately, actual initialization happens asynchronously
  }

  /**
   * Set multiplayer mode and role
   */
  setMultiplayerMode(mode, isHost = false) {
    this.setState({
      gameMode: mode,
    }, 'MULTIPLAYER_MODE_SET');
  }

  /**
   * Update player states
   */
  updatePlayers(player1Updates = {}, player2Updates = {}) {
    const updates = {};
    if (Object.keys(player1Updates).length > 0) {
      updates.player1 = { ...this.state.player1, ...player1Updates };
    }
    if (Object.keys(player2Updates).length > 0) {
      updates.player2 = { ...this.state.player2, ...player2Updates };
    }

    if (Object.keys(updates).length > 0) {
      this.setState(updates, 'PLAYERS_UPDATED');
    }
  }

  /**
   * Update specific player state directly
   */
  updatePlayerState(playerId, updates) {
    if (playerId === 'player1') {
      this.updatePlayers(updates, {});
    } else if (playerId === 'player2') {
      this.updatePlayers({}, updates);
    }
  }

  /**
   * Set player states directly (for gameLogic integration)
   */
  setPlayerStates(newPlayer1, newPlayer2) {
    this.setState({
      player1: newPlayer1,
      player2: newPlayer2
    }, 'PLAYER_STATES_SET');

    // DEBUG: Log event emission timing
    debugLog('RESOURCE_RESET', `ðŸ”” [GAMESTATEMANAGER] PLAYER_STATES_SET event emitted`, {
      timestamp: Date.now(),
      player1Energy: newPlayer1.energy,
      player1DeploymentBudget: newPlayer1.deploymentBudget,
      player2Energy: newPlayer2.energy,
      player2DeploymentBudget: newPlayer2.deploymentBudget
    });
  }

  /**
   * Set current player
   */
  setCurrentPlayer(playerId) {
    debugLog('TURN_TRANSITION_DEBUG', 'setCurrentPlayer called', {
      newPlayerId: playerId,
      previousPlayer: this.state.currentPlayer,
      subscriberCount: this.listeners.size
    });
    this.setState({ currentPlayer: playerId }, 'CURRENT_PLAYER_CHANGED');
  }

  /**
   * Set turn phase
   */
  setTurnPhase(phase) {
    this.setState({ turnPhase: phase }, 'TURN_PHASE_CHANGED');
  }

  /**
   * Set first player of round
   */
  setFirstPlayerOfRound(playerId) {
    this.setState({ firstPlayerOfRound: playerId }, 'FIRST_PLAYER_OF_ROUND_SET');
  }

  /**
   * Set first passer of previous round
   */
  setFirstPasserOfPreviousRound(playerId) {
    this.setState({ firstPasserOfPreviousRound: playerId }, 'FIRST_PASSER_OF_PREVIOUS_ROUND_SET');
  }

  /**
   * Set first player override
   */
  setFirstPlayerOverride(playerId) {
    this.setState({ firstPlayerOverride: playerId }, 'FIRST_PLAYER_OVERRIDE_SET');
  }

  /**
   * Update pass information
   */
  updatePassInfo(passUpdates) {
    const updatedPassInfo = { ...this.state.passInfo, ...passUpdates };
    this.setState({ passInfo: updatedPassInfo }, 'PASS_INFO_UPDATED');
  }

  /**
   * Set pass information directly
   */
  setPassInfo(passInfo) {
    this.setState({ passInfo: passInfo }, 'PASS_INFO_SET');
  }

  /**
   * Check if it's the local player's turn (for multiplayer)
   */
  isMyTurn() {
    // In local mode, player1 is the human player
    if (this.state.gameMode === 'local') return this.state.currentPlayer === 'player1';
    if (this.state.gameMode === 'host') return this.state.currentPlayer === 'player1';
    if (this.state.gameMode === 'guest') return this.state.currentPlayer === 'player2';
    return false;
  }

  /**
   * Get local player ID based on role
   */
  getLocalPlayerId() {
    if (this.state.gameMode === 'local') return 'player1'; // For local AI games
    if (this.state.gameMode === 'host') return 'player1';
    if (this.state.gameMode === 'guest') return 'player2';
    return 'player1';
  }

  /**
   * Get opponent player ID
   */
  getOpponentPlayerId() {
    const localId = this.getLocalPlayerId();
    return localId === 'player1' ? 'player2' : 'player1';
  }

  /**
   * Get local player state object
   */
  getLocalPlayerState() {
    const localId = this.getLocalPlayerId();
    return this.state[localId];
  }

  /**
   * Get opponent player state object
   */
  getOpponentPlayerState() {
    const opponentId = this.getOpponentPlayerId();
    return this.state[opponentId];
  }

  /**
   * Check if a given player ID is the local player (for UI perspective)
   */
  isLocalPlayer(playerId) {
    return playerId === this.getLocalPlayerId();
  }

  /**
   * Get placed sections for local player (UI perspective)
   */
  getLocalPlacedSections() {
    if (this.state.gameMode === 'local') return this.state.placedSections;
    if (this.state.gameMode === 'host') return this.state.placedSections;
    if (this.state.gameMode === 'guest') return this.state.opponentPlacedSections;
    return this.state.placedSections;
  }

  /**
   * Get placed sections for opponent (UI perspective)
   */
  getOpponentPlacedSections() {
    let result;
    if (this.state.gameMode === 'local') result = this.state.opponentPlacedSections;
    else if (this.state.gameMode === 'host') result = this.state.opponentPlacedSections;
    else if (this.state.gameMode === 'guest') result = this.state.placedSections;
    else result = this.state.opponentPlacedSections;

    // Only debug during placement phase when there's actual data
    if (this.state.turnPhase === 'placement' && result.some(s => s !== null)) {
      debugLog('STATE_SYNC', 'ðŸ” [DEBUG] GameStateManager.getOpponentPlacedSections:', {
        gameMode: this.state.gameMode,
        result,
        rawOpponentPlacedSections: this.state.opponentPlacedSections,
        rawPlacedSections: this.state.placedSections
      });
    }

    return result;
  }

  /**
   * Add log entry
   */
  addLogEntry(entry, debugSource = null, aiDecisionContext = null) {
    // Merge debugSource and aiDecisionContext into the entry object
    const enhancedEntry = {
      ...entry,
      timestamp: entry.timestamp || Date.now(),
      round: entry.round || this.state.turn
    };

    // Add debugSource if provided
    if (debugSource) {
      enhancedEntry.debugSource = debugSource;
    }

    // Add aiDecisionContext if provided
    if (aiDecisionContext) {
      enhancedEntry.aiDecisionContext = aiDecisionContext;
    }

    const updatedLog = [...this.state.gameLog, enhancedEntry];
    this.setState({ gameLog: updatedLog }, 'LOG_ENTRY_ADDED');
  }

  /**
   * Add AI decision to history for CSV export
   * @param {string} phase - Decision phase (deployment, action, interception)
   * @param {number} turn - Turn number
   * @param {Array} possibleActions - Array of all evaluated actions
   * @param {Object} gameState - Current game state snapshot
   */
  addAIDecisionToHistory(phase, turn, possibleActions, gameState) {
    // Create decision entry
    const decisionEntry = {
      phase,
      turn,
      timestamp: new Date().toISOString(),
      decisions: possibleActions.map(action => ({
        type: action.type,
        instigator: action.instigator,
        targetName: action.targetName,
        score: action.score,
        logic: action.logic || [],
        isChosen: action.isChosen || false
      })),
      gameState: {
        player1: {
          energy: gameState?.player1?.energy,
          dronesOnBoard: gameState?.player1?.dronesOnBoard
        },
        player2: {
          energy: gameState?.player2?.energy,
          dronesOnBoard: gameState?.player2?.dronesOnBoard
        }
      }
    };

    const updatedHistory = [...this.state.aiDecisionHistory, decisionEntry];
    this.setState({ aiDecisionHistory: updatedHistory }, 'AI_DECISION_ADDED');
  }

  /**
   * Set winner
   * For single-player extraction mode, processes combat outcome (victory/defeat)
   */
  setWinner(winnerId) {
    // Check if this is single-player extraction mode combat
    const currentState = this.getState();
    if (currentState.gameMode === 'singlePlayer' && tacticalMapStateManager.isRunActive()) {
      debugLog('SP_COMBAT', `Single-player combat ended. Winner: ${winnerId}`);

      // Just set winner - WinnerModal will handle transition via button click
      // CombatOutcomeProcessor.processCombatEnd() is called from WinnerModal
      this.setState({ winner: winnerId }, 'GAME_ENDED');
      return;
    }

    // Standard multiplayer/local mode
    this.setState({ winner: winnerId }, 'GAME_ENDED');
  }

  // --- ACTION PROCESSING ---

  /**
   * Process a game action through the action queue
   * @param {string} actionType - Type of action (attack, ability, deployment, etc.)
   * @param {Object} payload - Action-specific data
   * @returns {Promise} Resolves when action is complete
   */
  async processAction(actionType, payload) {
    return await this.actionProcessor.queueAction({
      type: actionType,
      payload: payload
    });
  }

  /**
   * Check if any actions are currently being processed
   */
  isActionInProgress() {
    return this.actionProcessor.isActionInProgress();
  }

  /**
   * Get current action queue length
   */
  getActionQueueLength() {
    return this.actionProcessor.getQueueLength();
  }

  /**
   * Emergency action queue clear (use with caution)
   */
  clearActionQueue() {
    this.actionProcessor.clearQueue();
    // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
    this.gameFlowManager?.resubscribe();
  }

  // --- SINGLE-PLAYER INVENTORY FACADES ---
  // External callers (EremosEntryScreen, SaveLoadModal, BlueprintsModal, RepairService) use these.
  // Delegation to singlePlayerInventoryManager.

  createNewSinglePlayerProfile() { this.singlePlayerInventoryManager.createNewSinglePlayerProfile(); }
  loadSinglePlayerSave(saveData) { this.singlePlayerInventoryManager.loadSinglePlayerSave(saveData); }
  getSaveData() { return this.singlePlayerInventoryManager.getSaveData(); }
  updateCardDiscoveryState(cardId, newState) { this.singlePlayerInventoryManager.updateCardDiscoveryState(cardId, newState); }
  addDiscoveredCard(cardId) { this.singlePlayerInventoryManager.addDiscoveredCard(cardId); }
  addToInventory(cardId, quantity = 1) { this.singlePlayerInventoryManager.addToInventory(cardId, quantity); }
  addShipComponentInstance(instance) { this.singlePlayerInventoryManager.addShipComponentInstance(instance); }
  updateShipComponentHull(instanceId, newHull) { this.singlePlayerInventoryManager.updateShipComponentHull(instanceId, newHull); }
  getShipComponentInstance(instanceId) { return this.singlePlayerInventoryManager.getShipComponentInstance(instanceId); }

  // --- TACTICAL ITEM FACADES ---
  // External callers (ShopModal, TacticalMapScreen, ExtractionController) use these.
  // Delegation to tacticalItemManager.

  purchaseTacticalItem(itemId) { return this.tacticalItemManager.purchaseTacticalItem(itemId); }
  purchaseCardPack() { return this.tacticalItemManager.purchaseCardPack(); }
  useTacticalItem(itemId) { return this.tacticalItemManager.useTacticalItem(itemId); }
  getTacticalItemCount(itemId) { return this.tacticalItemManager.getTacticalItemCount(itemId); }

  // --- SHIP SLOT FACADES ---
  // External callers (HangarScreen, RepairBayScreen, ExtractionDeckBuilder, DroneDamageProcessor) use these.
  // Delegation to shipSlotManager.

  setDefaultShipSlot(slotId) { this.shipSlotManager.setDefaultShipSlot(slotId); }
  isSlotUnlocked(slotId) { return this.shipSlotManager.isSlotUnlocked(slotId); }
  getNextUnlockableSlot() { return this.shipSlotManager.getNextUnlockableSlot(); }
  unlockNextDeckSlot() { return this.shipSlotManager.unlockNextDeckSlot(); }
  saveShipSlotDeck(slotId, deckData) { this.shipSlotManager.saveShipSlotDeck(slotId, deckData); }
  deleteShipSlotDeck(slotId) { this.shipSlotManager.deleteShipSlotDeck(slotId); }
  clearSlotInstances(slotId) { this.shipSlotManager.clearSlotInstances(slotId); }
  updateShipSlotDroneOrder(slotId, newDroneSlots) { this.shipSlotManager.updateShipSlotDroneOrder(slotId, newDroneSlots); }
  repairDroneSlot(slotId, position) { return this.shipSlotManager.repairDroneSlot(slotId, position); }
  repairSectionSlot(slotId, lane) { return this.shipSlotManager.repairSectionSlot(slotId, lane); }
  repairSectionSlotPartial(slotId, lane, hpToRepair) { return this.shipSlotManager.repairSectionSlotPartial(slotId, lane, hpToRepair); }
  createDroneInstance(droneName, slotId) { return this.shipSlotManager.createDroneInstance(droneName, slotId); }
  updateDroneInstance(instanceId, isDamaged) { this.shipSlotManager.updateDroneInstance(instanceId, isDamaged); }
  findDroneInstance(slotId, droneName) { return this.shipSlotManager.findDroneInstance(slotId, droneName); }
  getDroneDamageStateForSlot(slotId) { return this.shipSlotManager.getDroneDamageStateForSlot(slotId); }
  createComponentInstance(componentId, slotId) { return this.shipSlotManager.createComponentInstance(componentId, slotId); }

  // --- RUN LIFECYCLE FACADES ---
  // External callers (HangarScreen, CombatOutcomeProcessor, ExtractionController, DetectionManager) use these.
  // Delegation to runLifecycleManager.

  startRun(...args) { this.runLifecycleManager.startRun(...args); }
  endRun(...args) { this.runLifecycleManager.endRun(...args); }

  /**
   * Reset game state to pre-game defaults
   * Used when abandoning mid-combat or exiting games to ensure clean state
   * This is the SINGLE SOURCE OF TRUTH for combat state cleanup
   */
  resetGameState() {
    debugLog('SP_COMBAT', '=== RESET GAME STATE ===');

    // Set context to GameFlowManager since resetGameState legitimately resets
    // game orchestration state (this avoids ownership violations when called
    // from CombatOutcomeProcessor.finalizeLootCollection or other paths)
    this._updateContext = 'GameFlowManager';

    try {
      this.setState({
        // Game flow state
        gameActive: false,
        testMode: false,
        gameSeed: null,
        turnPhase: null,
        gameStage: 'preGame',
        roundNumber: 0,
        turn: 1,
        currentPlayer: 'player1',
        actionsTakenThisTurn: 0,
        firstPlayerOfRound: null,
        firstPasserOfPreviousRound: null,
        firstPlayerOverride: null,

        // Player states
        player1: null,
        player2: null,

        // Pass state
        passInfo: {
          firstPasser: null,
          player1Passed: false,
          player2Passed: false
        },

        // Combat state
        attackInProgress: null,
        lastCombatResult: null,
        winner: null,
        singlePlayerEncounter: null,

        // UI state - ship placement
        placedSections: [],
        opponentPlacedSections: [],
        unplacedSections: [],

        // UI state - game
        gameLog: [],
        commitments: {},
        shieldsToAllocate: 0,
        opponentShieldsToAllocate: 0,

        // Drone selection state
        droneSelectionPool: [],
        droneSelectionTrio: []
      }, 'GAME_STATE_RESET');

      // Reset singletons to ensure clean state for next combat
      // These are idempotent - safe to call multiple times

      // GameFlowManager - reset phase/stage tracking
      if (this.gameFlowManager?.reset) {
        this.gameFlowManager.reset();
        debugLog('SP_COMBAT', 'âœ… GameFlowManager reset');
      }

      // ActionProcessor - clear queue and locks
      if (this.actionProcessor?.clearQueue) {
        this.actionProcessor.clearQueue();
        // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
        this.gameFlowManager?.resubscribe();
        debugLog('SP_COMBAT', 'âœ… ActionProcessor queue cleared');
      }

      // AIPhaseProcessor - cleanup subscriptions and timers
      if (aiPhaseProcessor?.cleanup) {
        aiPhaseProcessor.cleanup();
        debugLog('SP_COMBAT', 'âœ… AIPhaseProcessor cleaned up');
      }
    } finally {
      this._updateContext = null;
    }
  }

}

// Create singleton instance
const gameStateManager = new GameStateManager();

// Preserve singleton across Hot Module Replacement (HMR) in development
// This prevents state loss during development when files are edited
if (import.meta.hot) {
  import.meta.hot.accept();
  // Store the current instance in HMR data to preserve across reloads
  if (import.meta.hot.data?.gameStateManager) {
    // Restore the previous instance's state
    gameStateManager.state = import.meta.hot.data.gameStateManager.state;
    gameStateManager.listeners = import.meta.hot.data.gameStateManager.listeners;
    debugLog('STATE_SYNC', 'ðŸ”„ HMR: Preserved GameStateManager state across hot reload');
  }
  import.meta.hot.dispose((data) => {
    // Store instance before disposing
    data.gameStateManager = gameStateManager;
  });
}

export default gameStateManager;