// ========================================
// GAME STATE MANAGER
// ========================================
// Centralized game state management for multiplayer support.
// Separates core game state from UI state and provides event-driven updates.

import { gameEngine, startingDecklist } from '../logic/gameLogic.js';
import ActionProcessor from './ActionProcessor.js';
import GameDataService from '../services/GameDataService.js';
import GuestMessageQueueService from './GuestMessageQueueService.js';
import OptimisticActionService from './OptimisticActionService.js';
import fullDroneCollection from '../data/droneData.js';
import { initializeDroneSelection } from '../utils/droneSelectionUtils.js';
import { debugLog } from '../utils/debugLogger.js';
import { createNewSave, starterPoolCards, starterPoolDroneNames, convertComponentsToSectionSlots } from '../data/saveGameSchema.js';
import { ECONOMY } from '../data/economyData.js';
import { generateMapData } from '../utils/mapGenerator.js';
import CombatOutcomeProcessor from '../logic/singlePlayer/CombatOutcomeProcessor.js';
import { shipComponentCollection } from '../data/shipSectionData.js';
import { getAllShips, getDefaultShip } from '../data/shipData.js';
import { calculateSectionBaseStats } from '../logic/statsCalculator.js';
import fullCardCollection from '../data/cardData.js';
import ReputationService from '../logic/reputation/ReputationService.js';
import { calculateExtractedCredits } from '../logic/singlePlayer/ExtractionController.js';
import { getTacticalItemById } from '../data/tacticalItemData.js';
import { generateRandomShopPack, getPackCostForTier } from '../data/cardPackData.js';
import rewardManager from './RewardManager.js';
import aiPhaseProcessor from './AIPhaseProcessor.js';
import tacticalMapStateManager from './TacticalMapStateManager.js';
import transitionManager from './TransitionManager.js';
// PhaseManager dependency removed - using direct phase checks

class GameStateManager {
  constructor() {
    debugLog('STATE_SYNC', 'üîÑ GAMESTATE INITIALIZATION: Creating new GameStateManager instance');

    // Event listeners for state changes
    this.listeners = new Set();

    // Optimistic action tracking for client-side prediction (guest mode)
    // Uses fine-grained animation deduplication service
    this.optimisticActionService = new OptimisticActionService();

    // Core application state (minimal until game starts)
    this.state = {
      // --- APPLICATION STATE ---
      appState: 'menu', // 'menu', 'inGame', 'gameOver'

      // --- MULTIPLAYER STATE ---
      isConnected: false,
      opponentId: null,
      gameMode: 'local', // 'local', 'host', 'guest'

      // --- TESTING MODE ---
      testMode: false, // Indicates if this is a test game (bypasses normal flow)

      // --- GAME STATE (null until game starts) ---
      gameActive: false,
      gameSeed: null, // Random seed for deterministic gameplay (generated by Host/Local, received by Guest)
      turnPhase: null,
      turn: null,
      currentPlayer: null,
      actionsTakenThisTurn: 0,  // Track actions for NOT_FIRST_ACTION ability condition
      firstPlayerOfRound: null,
      firstPasserOfPreviousRound: null,
      firstPlayerOverride: null,
      passInfo: null,
      winner: null,
      player1: null,
      player2: null,
      placedSections: [],
      opponentPlacedSections: [],
      unplacedSections: [],
      shieldsToAllocate: 0,
      droneSelectionPool: [],
      droneSelectionTrio: [],
      gameLog: [],
      aiDecisionHistory: [], // Array of AI decision entries for CSV export

      // --- GAME FLOW METADATA (owned by GameFlowManager) ---
      gameStage: 'preGame', // 'preGame', 'roundLoop', 'gameOver'
      roundNumber: 0,

      // --- COMMITMENTS (for simultaneous phases) ---
      commitments: {},

      // --- SINGLE-PLAYER STATE (Extraction Mode) ---
      singlePlayerProfile: null,         // Player profile data
      singlePlayerInventory: {},         // Card inventory (master quantities)
      singlePlayerDroneInstances: [],    // Drone instances with damage tracking
      singlePlayerShipComponentInstances: [],  // Ship component instances with hull tracking
      singlePlayerDiscoveredCards: [],   // Card discovery states (owned/discovered/undiscovered)
      singlePlayerShipSlots: [],         // 6 ship slots
      // NOTE: currentRunState has been moved to TacticalMapStateManager
      quickDeployments: [],              // Quick deploy templates (max 5)

      // --- EXTRACTION DECK BUILDER NAVIGATION ---
      extractionDeckSlotId: null,        // Slot ID being edited (0-5) or null
      extractionNewDeckOption: null,     // 'empty' | 'copyFromSlot0' | null

      // --- FAILED RUN LOADING SCREEN ---
      showFailedRunScreen: false,        // Show failed run transition screen
      failedRunType: null,               // 'combat' | 'detection' | 'abandon'
      failedRunIsStarterDeck: false,     // If true, show "RUN FAILED" instead of "SHIP MARKED MIA"
    };

    // Initialize action processor using singleton pattern
    // PhaseAnimationQueue will be injected later in AppRouter
    this.actionProcessor = ActionProcessor.getInstance(this, null);

    // Game flow manager reference (set during initialization)
    this.gameFlowManager = null;

    // Guest message queue service (initialized when guest joins)
    this.guestQueueService = null;

    // P2P integration will be set up lazily when needed
    this.p2pIntegrationSetup = false;

    // Context flag for production-safe validation (avoids minification breaking stack traces)
    this._updateContext = null;

    // --- CHECKPOINT PHASES (Guest Validation) ---
    // Phases where guest stops and validates state with host
    // Includes all simultaneous phases that require player interaction
    this.MILESTONE_PHASES = ['droneSelection', 'placement', 'mandatoryDiscard', 'optionalDiscard', 'allocateShields', 'mandatoryDroneRemoval', 'deployment'];

    // --- VALIDATION STATE (Guest) ---
    // Tracks when guest is waiting for specific broadcast to validate optimistic state
    this.validatingState = {
      isValidating: false,
      targetPhase: null,      // Phase we're expecting from host
      guestState: null,       // Guest's optimistic state snapshot
      timestamp: null         // When we started validating
    };

    // Log initial application state
    debugLog('STATE_SYNC', 'üîÑ GAMESTATE INITIALIZATION: GameStateManager created');
    debugLog('STATE_SYNC', 'üì± App State:', this.state.appState);
    debugLog('STATE_SYNC', 'üéÆ Game Active:', this.state.gameActive);
    debugLog('STATE_SYNC', '‚úÖ GAMESTATE INITIALIZATION: GameStateManager ready (no game active)');
  }

  // --- MANAGER REFERENCES ---

  /**
   * Set the GameFlowManager reference
   * @param {Object} gameFlowManager - GameFlowManager instance
   */
  setGameFlowManager(gameFlowManager) {
    this.gameFlowManager = gameFlowManager;
  }

  // --- P2P INTEGRATION ---

  /**
   * Set up P2P integration (called lazily when needed)
   * @param {Object} p2pManager - P2P manager instance
   */
  setupP2PIntegration(p2pManager) {
    if (this.p2pIntegrationSetup) return;

    // Wire up bidirectional integration
    this.actionProcessor.setP2PManager(p2pManager);
    p2pManager.setActionProcessor(this.actionProcessor);

    // Subscribe to P2P events
    p2pManager.subscribe((event) => {
      switch (event.type) {
        case 'multiplayer_mode_change':
          this.setMultiplayerMode(event.data.mode, event.data.isHost);

          // Initialize guest queue service when becoming guest
          if (event.data.mode === 'guest' && !this.guestQueueService) {
            debugLog('STATE_SYNC', 'üéØ [GUEST QUEUE] Initializing service for guest mode');
            const phaseAnimationQueue = this.actionProcessor?.phaseAnimationQueue || null;
            this.guestQueueService = new GuestMessageQueueService(this, phaseAnimationQueue);
            this.guestQueueService.initialize(p2pManager);
          }
          break;
        case 'state_update_received':
          // Guest mode: Route through queue service for sequential processing
          // Host mode: Not applicable (host doesn't receive state updates)
          if (this.state.gameMode === 'guest') {
            if (this.guestQueueService) {
              // Queue service handles this - no need to do anything here
              // Service is already subscribed to P2P events
            } else {
              console.warn('‚ö†Ô∏è [GUEST QUEUE] Service not initialized, applying state directly (fallback)');
              this.applyHostState(event.data.state);
              // Note: Animations will be lost in fallback mode
            }
          }
          break;
        case 'state_sync_requested':
          // Send current state for initial sync (deprecated, kept for compatibility)
          const currentState = this.getState();
          p2pManager.sendData({
            type: 'GAME_STATE_SYNC',
            state: currentState,
            timestamp: Date.now(),
          });
          break;
      }
    });

    this.p2pIntegrationSetup = true;
  }


  /**
   * Start validation mode - guest expects specific phase broadcast from host
   * @param {string} targetPhase - Phase to validate against
   * @param {Object} guestState - Guest's current optimistic state
   */
  startValidation(targetPhase, guestState) {
    this.validatingState = {
      isValidating: true,
      targetPhase: targetPhase,
      guestState: JSON.parse(JSON.stringify(guestState)), // Deep copy
      timestamp: Date.now()
    };

    debugLog('VALIDATION', 'üîç [START VALIDATION] Waiting for host broadcast', {
      targetPhase,
      currentPhase: guestState.turnPhase
    });
  }

  /**
   * Check if incoming broadcast should trigger validation
   * @param {string} incomingPhase - Phase from incoming broadcast
   * @returns {boolean} True if this broadcast matches validation target
   */
  shouldValidateBroadcast(incomingPhase) {
    return this.validatingState.isValidating &&
           this.validatingState.targetPhase === incomingPhase;
  }

  /**
   * Check if a phase is a milestone (requires user interaction)
   * @param {string} phase - Phase to check
   * @returns {boolean} True if milestone phase
   */
  isMilestonePhase(phase) {
    return this.MILESTONE_PHASES.includes(phase);
  }

  /**
   * Apply state update from host (guest only)
   * Guest is a thin client that receives authoritative state from host
   * NOTE: Animations are handled by GuestMessageQueueService after render
   * @param {Object} hostState - Complete game state from host
   */
  applyHostState(hostState) {
    if (this.state.gameMode !== 'guest') {
      console.warn('‚ö†Ô∏è applyHostState should only be called in guest mode');
      return;
    }

    // VALIDATION LOG: Verify state before/after application
    const beforeFields = Object.keys(this.state).length;
    debugLog('BROADCAST_TIMING', `üìù [GUEST APPLY] Before: ${beforeFields} fields | Incoming: ${Object.keys(hostState).length} fields | Phase: ${hostState.turnPhase} ‚Üí ${this.state.turnPhase}`);

    debugLog('STATE_SYNC', '[GUEST STATE UPDATE] Applying state from host:', {
      turnPhase: hostState.turnPhase,
      currentPlayer: hostState.currentPlayer,
      roundNumber: hostState.roundNumber
    });

    debugLog('STATE_SYNC', '[GUEST] Received player2 hand from host:', {
      handSize: hostState.player2?.hand?.length || 0,
      sampleCard: hostState.player2?.hand?.[0] || null,
      sampleInstanceId: hostState.player2?.hand?.[0]?.instanceId,
      hasInstanceId: hostState.player2?.hand?.[0]?.instanceId !== undefined
    });

    // Log commitment values if present
    if (hostState.commitments && Object.keys(hostState.commitments).length > 0) {
      debugLog('COMMITMENTS', '[GUEST] Received commitment values from host:', {
        phases: Object.keys(hostState.commitments),
        fullCommitments: hostState.commitments,
        currentPhase: hostState.turnPhase
      });

      // Log specific commitment status for current phase
      const currentPhaseCommitments = hostState.commitments[hostState.turnPhase];
      if (currentPhaseCommitments) {
        debugLog('COMMITMENTS', `[GUEST] Current phase (${hostState.turnPhase}) commitment status:`, {
          player1Completed: currentPhaseCommitments.player1?.completed || false,
          player2Completed: currentPhaseCommitments.player2?.completed || false
        });
      }
    }

    // Preserve guest's local gameMode (guest must know it's the guest)
    const localGameMode = this.state.gameMode;

    // Guest directly applies host's authoritative state without validation
    // No game logic execution on guest side
    this.state = { ...hostState };

    // Restore guest's gameMode so it knows which player it controls
    this.state.gameMode = localGameMode;

    // VALIDATION LOG: Verify critical fields after application
    const missing = [];
    if (this.state.turnPhase === undefined) missing.push('turnPhase');
    if (this.state.currentPlayer === undefined) missing.push('currentPlayer');
    if (this.state.player1 === undefined) missing.push('player1');
    if (this.state.player2 === undefined) missing.push('player2');
    if (missing.length > 0) {
      debugLog('BROADCAST_TIMING', `üö® [GUEST APPLY] MISSING FIELDS: ${missing.join(', ')}`);
    } else {
      debugLog('BROADCAST_TIMING', `‚úÖ [GUEST APPLY] State complete | After: ${Object.keys(this.state).length} fields`);
    }

    debugLog('STATE_SYNC', '[GUEST] After applying state - player2 hand check:', {
      handSize: this.state.player2?.hand?.length || 0,
      sampleCard: this.state.player2?.hand?.[0] || null,
      sampleInstanceId: this.state.player2?.hand?.[0]?.instanceId,
      hasInstanceId: this.state.player2?.hand?.[0]?.instanceId !== undefined
    });

    // Emit state change for UI updates (triggers React re-render)
    this.emit('HOST_STATE_UPDATE', { hostState });

    // Animations are executed by GuestMessageQueueService after React renders
  }

  // --- EVENT SYSTEM ---

  /**
   * Subscribe to state changes
   * @param {Function} listener - Callback function called when state changes
   * @returns {Function} Unsubscribe function
   */
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Notify all listeners of state change
   * @param {string} type - Type of change
   * @param {Object} payload - Additional data
   */
  emit(type, payload = {}) {
    this.listeners.forEach(listener => {
      try {
        listener({ type, payload, state: this.getState() });
      } catch (error) {
        console.error('Error in state listener:', error);
      }
    });
  }

  // --- STATE ACCESS ---

  /**
   * Get current state (read-only)
   */
  getState() {
    return { ...this.state };
  }

  /**
   * Get specific state property
   */
  get(key) {
    return this.state[key];
  }

  /**
   * Update state and notify listeners
   * @param {Object} updates - State updates to apply
   * @param {string} eventType - Type of event for logging
   * @param {string} context - Context of the update for validation (e.g., 'phaseTransition')
   */
  setState(updates, eventType = 'STATE_UPDATE', context = null) {
    const prevState = { ...this.state };

    // CRITICAL: Log appState transitions for extraction mode debugging
    if (updates.appState && updates.appState !== this.state.appState) {
      debugLog('EXTRACTION', 'appState transition', {
        from: this.state.appState,
        to: updates.appState,
        hasRunState: tacticalMapStateManager.isRunActive(),
        runAbandoning: this.state.runAbandoning,
        eventType
      });
    }

    // Extract caller information from stack trace for detailed logging
    const stack = new Error().stack;
    const stackLines = stack ? stack.split('\n') : [];
    const callerInfo = this.extractCallerInfo(stackLines);

    // Check for architecture violations - App.jsx should NEVER directly update GameStateManager
    // However, App.jsx can call ActionProcessor/PhaseManager/ExtractionController which then update GameStateManager
    const isAppJsxCaller = stackLines.some(line => line.includes('App.jsx'));
    const isViaActionProcessor = stackLines.some(line => line.includes('ActionProcessor'));
    const isViaPhaseManager = stackLines.some(line => line.includes('PhaseManager'));
    const isViaExtractionController = stackLines.some(line => line.includes('ExtractionController'));
    const isLegitimateCall = isViaActionProcessor || isViaPhaseManager || isViaExtractionController;

    if (isAppJsxCaller && !isLegitimateCall) {
      console.error('üö® ARCHITECTURE VIOLATION: App.jsx is directly updating GameStateManager!');
      console.error('üìã App.jsx should only call ActionProcessor, PhaseManager, or ExtractionController methods');
      console.error('üîç Stack trace:', stack);
    }

    // Comprehensive state change logging
    const updateKeys = Object.keys(updates);
    const caller = `${callerInfo.primaryCaller} in ${callerInfo.primaryFile}`;

    debugLog('STATE_SYNC', `üîç GAMESTATE CHANGE [${eventType}] from ${caller}:`, {
      changedKeys: updateKeys,
      allUpdates: updates,
      architectureViolation: isAppJsxCaller && !isLegitimateCall
    });

    // Special detailed logging for player state changes (skip during initialization)
    const isInitializationEvent = ['GAME_RESET', 'INITIALIZATION'].includes(eventType);
    if ((updates.player1 || updates.player2) && !isInitializationEvent) {
      this.logPlayerStateChanges(updates, prevState, caller, eventType);
    }

    // Log other critical state changes
    updateKeys.forEach(key => {
      if (!['player1', 'player2'].includes(key)) {
        const oldValue = prevState[key];
        const newValue = updates[key];
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
          debugLog('STATE_SYNC', `üîç STATE CHANGE: ${key}`, {
            before: oldValue,
            after: newValue,
            caller: caller,
            eventType: eventType
          });
        }
      }
    });

    // Validate state consistency before update
    this.validateStateUpdate(updates, prevState, context);

    this.state = { ...this.state, ...updates };
    this.emit(eventType, { updates, prevState });
  }

  /**
   * Validate state updates for consistency and race conditions
   * @param {Object} updates - State updates being applied
   * @param {Object} prevState - Previous state before updates
   * @param {string} context - Context of the update (e.g., 'phaseTransition')
   */
  validateStateUpdate(updates, prevState, context = null) {
    // Get the current call stack to see if this update is coming from ActionProcessor
    // Use context flag first (production-safe) then fall back to stack trace (dev-only)
    const stack = new Error().stack;
    const isFromActionProcessor = this._updateContext === 'ActionProcessor' || (stack && stack.includes('ActionProcessor'));

    // Check for concurrent action processing - only warn about external updates
    // ActionProcessor is allowed to update state during action processing
    // GameFlowManager is allowed to update phase transitions as legitimate side effects
    if (this.actionProcessor.isActionInProgress() && Object.keys(updates).length > 0) {
      if (!isFromActionProcessor) {
        const dangerousUpdates = ['player1', 'player2', 'turnPhase', 'currentPlayer'];
        const hasDangerousUpdate = dangerousUpdates.some(key => key in updates);

        // Check if this is a legitimate phase transition from GameFlowManager
        // Use context flag first (production-safe) then fall back to stack trace (dev-only)
        const isFromGameFlowManager = this._updateContext === 'GameFlowManager' || (stack && stack.includes('GameFlowManager'));
        const isPhaseTransition = context === 'phaseTransition' || (updates.turnPhase && isFromGameFlowManager);

        // Only warn about truly problematic external updates, not legitimate manager flows
        const isLegitimateManagerUpdate = isPhaseTransition && isFromGameFlowManager;

        if (hasDangerousUpdate && !isLegitimateManagerUpdate) {
          console.warn('Race condition detected: External state update during action processing', {
            updates: Object.keys(updates),
            actionInProgress: true,
            queueLength: this.actionProcessor.getQueueLength(),
            context: context,
            isFromGameFlowManager: isFromGameFlowManager,
            isPhaseTransition: isPhaseTransition,
            stack: stack?.split('\n').slice(0, 5) // First 5 lines of stack for debugging
          });
        }
      }
    }

    // Check for ActionProcessor bypass during active gameplay phases
    this.validateActionProcessorUsage(updates, prevState, isFromActionProcessor, stack);

    // Validate player state consistency
    if (updates.player1 || updates.player2) {
      this.validatePlayerStates(updates.player1 || prevState.player1, updates.player2 || prevState.player2);
    }

    // Validate turn phase transitions
    if (updates.turnPhase && updates.turnPhase !== prevState.turnPhase) {
      this.validateTurnPhaseTransition(prevState.turnPhase, updates.turnPhase);
    }
  }

  /**
   * Validate player states for data integrity
   */
  validatePlayerStates(player1, player2) {
    if (!player1 || !player2) return;

    // Check for negative values (only if player exists with these properties)
    const validatePlayerValues = (player, playerId) => {
      if (!player) return;
      if (typeof player.energy === 'number' && player.energy < 0) {
        console.error(`Invalid state: ${playerId} has negative energy: ${player.energy}`);
      }
      if (typeof player.deploymentBudget === 'number' && player.deploymentBudget < 0) {
        console.error(`Invalid state: ${playerId} has negative deployment budget: ${player.deploymentBudget}`);
      }
    };

    validatePlayerValues(player1, 'player1');
    validatePlayerValues(player2, 'player2');

    // Check for duplicate drone IDs (only if dronesOnBoard exists)
    const allDroneIds = new Set();
    [player1, player2].forEach((player, playerIndex) => {
      if (player?.dronesOnBoard) {
        Object.values(player.dronesOnBoard).forEach(lane => {
          lane.forEach(drone => {
            if (allDroneIds.has(drone.id)) {
              console.error(`Duplicate drone ID detected: ${drone.id} in player${playerIndex + 1}`);
            }
            allDroneIds.add(drone.id);
          });
        });
      }
    });
  }

  /**
   * Validate turn phase transitions
   */
  validateTurnPhaseTransition(fromPhase, toPhase) {
    // Skip validation for test mode - allows direct state initialization
    if (this.state.testMode) {
      return;
    }

    const validTransitions = {
      null: ['deckSelection', 'preGame', 'roundInitialization'],  // roundInitialization added for SP combat init
      'preGame': ['deckSelection', 'droneSelection'],
      'deckSelection': ['droneSelection'],
      'droneSelection': ['placement'],
      'placement': ['gameInitializing', 'roundInitialization', 'roundAnnouncement'],  // Added roundAnnouncement for Round 1
      'gameInitializing': ['determineFirstPlayer'],
      'roundInitialization': ['mandatoryDiscard', 'optionalDiscard', 'allocateShields', 'mandatoryDroneRemoval', 'deployment'],
      'roundAnnouncement': ['roundInitialization', 'deployment'],  // Pseudo-phase: can go to roundInitialization or directly to deployment
      'energyReset': ['mandatoryDiscard', 'optionalDiscard', 'draw', 'allocateShields', 'mandatoryDroneRemoval', 'deployment'],
      'initialDraw': ['mandatoryDiscard', 'optionalDiscard', 'draw', 'allocateShields', 'mandatoryDroneRemoval', 'deployment'],
      'mandatoryDiscard': ['optionalDiscard', 'draw', 'allocateShields', 'mandatoryDroneRemoval', 'deployment'],
      'optionalDiscard': ['draw', 'allocateShields', 'mandatoryDroneRemoval', 'deployment'],
      'draw': ['allocateShields', 'mandatoryDroneRemoval', 'deployment'],
      'determineFirstPlayer': ['energyReset'],
      'allocateShields': ['mandatoryDroneRemoval', 'deployment'],
      'mandatoryDroneRemoval': ['deployment'],
      'deployment': ['action', 'roundEnd'],
      'action': ['deployment', 'roundEnd', 'determineFirstPlayer', 'gameEnd', 'actionComplete'],  // Added actionComplete
      'actionComplete': ['roundAnnouncement'],  // Pseudo-phase: always goes to roundAnnouncement (new round)
      'roundEnd': ['determineFirstPlayer', 'deployment', 'gameEnd'],
      'gameEnd': []
    };

    if (!validTransitions[fromPhase]?.includes(toPhase)) {
      console.warn(`Invalid turn phase transition: ${fromPhase} -> ${toPhase}`);
    }
  }

  /**
   * Validate ActionProcessor usage during active gameplay
   */
  validateActionProcessorUsage(updates, prevState, isFromActionProcessor, stack) {
    // Skip validation if this update is from ActionProcessor
    if (isFromActionProcessor) {
      return;
    }

    // Skip validation during initialization and setup phases
    if (this.isInitializationPhase(prevState.turnPhase)) {
      return;
    }

    // First check if GameFlowManager is currently processing an automatic phase
    debugLog('STATE_SYNC', 'üîç Checking automatic phase flag:', {
      hasGameFlowManager: !!this.gameFlowManager,
      isProcessingAutomaticPhase: this.gameFlowManager?.isProcessingAutomaticPhase,
      currentPhase: prevState.turnPhase,
      updatingFields: Object.keys(updates)
    });

    if (this.gameFlowManager && this.gameFlowManager.isProcessingAutomaticPhase) {
      debugLog('STATE_SYNC', '‚úÖ Skipping validation - automatic phase processing active');
      return; // Skip validation during automatic phase processing
    }

    // Skip validation during simultaneous phases - direct updates are expected
    const simultaneousPhases = ['droneSelection', 'deckSelection', 'placement', 'gameInitializing', 'mandatoryDiscard', 'allocateShields', 'mandatoryDroneRemoval'];
    if (simultaneousPhases.includes(prevState.turnPhase)) {
      return;
    }

    // Skip validation during automatic phases - GameFlowManager handles these directly
    const automaticPhases = ['energyReset', 'draw', 'determineFirstPlayer', 'roundInitialization'];
    if (automaticPhases.includes(prevState.turnPhase) || automaticPhases.includes(updates.turnPhase)) {
      return;
    }

    // Define critical game state changes that should go through ActionProcessor
    const criticalGameStateUpdates = [
      'player1',           // Player state changes
      'player2',           // Player state changes
      'currentPlayer',     // Turn management
      'turnPhase',        // Phase transitions
      'turn',             // Round progression
      'passInfo',         // Pass state management
      'winner',           // Game end state
      'firstPlayerOfRound', // Turn order management
      'firstPasserOfPreviousRound' // Turn order management
    ];

    // Define UI state updates that are allowed to bypass ActionProcessor
    const allowedUIStateUpdates = [
      'gameLog',          // Logging is UI state
      'shieldsToAllocate', // Already handled by shield allocation actions
      'placedSections',   // UI-level placement state (debatable)
      'opponentPlacedSections', // UI-level placement state (debatable)
      'unplacedSections', // UI-level placement state (debatable)
      'droneSelectionPool', // UI-level drone selection state
      'droneSelectionTrio'  // UI-level drone selection state
    ];

    // Check for critical updates that bypass ActionProcessor
    const criticalUpdates = Object.keys(updates).filter(key =>
      criticalGameStateUpdates.includes(key)
    );

    const allowedUpdates = Object.keys(updates).filter(key =>
      allowedUIStateUpdates.includes(key)
    );

    // Allow GameFlowManager to update player states during automatic phases
    // Use context flag first (production-safe) then fall back to stack trace (dev-only)
    const isGameFlowManagerUpdate = this._updateContext === 'GameFlowManager' || (stack && stack.includes('GameFlowManager'));
    const isAutomaticPhaseUpdate = ['energyReset', 'draw', 'determineFirstPlayer'].includes(prevState.turnPhase) ||
                                    ['deployment', 'action'].includes(prevState.turnPhase); // After automatic phases
    const isPlayerStateUpdate = criticalUpdates.every(update =>
      ['player1', 'player2'].includes(update)
    );

    // Also allow GameFlowManager to update phase-related fields
    const isPhaseTransitionUpdate = criticalUpdates.every(update =>
      ['turnPhase', 'gameStage', 'roundNumber', 'turn', 'firstPlayerOfRound', 'firstPasserOfPreviousRound'].includes(update)
    );

    if (isGameFlowManagerUpdate && (isPlayerStateUpdate || isPhaseTransitionUpdate)) {
      return; // Allow GameFlowManager to manage phases and update player states
    }

    // Allow SequentialPhaseManager to update passInfo during sequential phases
    const isSequentialPhaseManagerUpdate = stack && stack.includes('SequentialPhaseManager');
    const isSequentialPhase = ['deployment', 'action'].includes(prevState.turnPhase);
    const isPassInfoUpdate = criticalUpdates.length === 1 && criticalUpdates[0] === 'passInfo';

    if (isSequentialPhaseManagerUpdate && isSequentialPhase && isPassInfoUpdate) {
      return; // Allow SequentialPhaseManager to manage pass state for sequential phases
    }

    if (criticalUpdates.length > 0 && !isFromActionProcessor) {
      // Extract caller information from stack trace
      const stackLines = stack?.split('\n') || [];
      const callerLine = stackLines.find(line =>
        line.includes('.jsx') && !line.includes('GameStateManager')
      ) || stackLines[2] || 'Unknown';

      console.warn('‚ö†Ô∏è ActionProcessor bypass detected: Critical game state updated directly', {
        updates: criticalUpdates,
        turnPhase: prevState.turnPhase,
        caller: callerLine.trim(),
        allUpdates: Object.keys(updates),
        actionInProgress: this.actionProcessor.isActionInProgress(),
        recommendation: 'Use processAction() instead of direct state updates'
      });

      // Log detailed debug information
      console.debug('üêõ ActionProcessor bypass debug info:', {
        stackTrace: stackLines.slice(0, 8),
        currentState: {
          turnPhase: prevState.turnPhase,
          currentPlayer: prevState.currentPlayer,
          turn: prevState.turn
        },
        updateDetails: updates
      });
    }

    // Log informational message for allowed UI updates (only in debug mode)
    if (allowedUpdates.length > 0 && !isFromActionProcessor && process.env.NODE_ENV === 'development') {
      console.debug('‚ÑπÔ∏è UI state update (allowed):', {
        updates: allowedUpdates,
        turnPhase: prevState.turnPhase
      });
    }

    // Validate that appropriate functions are updating game state
    this.validateFunctionAppropriateForStateUpdate(updates, prevState, isFromActionProcessor, stack);

    // Validate ownership boundaries - each manager should only update fields it owns
    this.validateOwnershipBoundaries(updates, stack);
  }

  /**
   * Log detailed player state changes for debugging
   */
  logPlayerStateChanges(updates, prevState, caller, eventType) {
    ['player1', 'player2'].forEach(playerId => {
      if (updates[playerId]) {
        const oldPlayer = prevState[playerId];
        const newPlayer = updates[playerId];

        debugLog('STATE_SYNC', `üö® PLAYER STATE CHANGE [${playerId}] [${eventType}] from ${caller}:`);

        // Critical properties that commonly cause AI issues
        const criticalProps = ['energy', 'activeDronePool', 'hand', 'deck', 'dronesOnBoard', 'deploymentBudget', 'initialDeploymentBudget'];

        criticalProps.forEach(prop => {
          const oldValue = oldPlayer ? oldPlayer[prop] : undefined;
          const newValue = newPlayer ? newPlayer[prop] : undefined;

          if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
            // Special formatting for different property types
            if (prop === 'energy' || prop === 'deploymentBudget' || prop === 'initialDeploymentBudget') {
              debugLog('STATE_SYNC', `  üí∞ ${prop}: ${oldValue} ‚Üí ${newValue}`);
              if (newValue === undefined || newValue === null || isNaN(newValue)) {
                console.error(`  üö® WARNING: ${prop} became ${newValue}!`);
              }
            } else if (prop === 'activeDronePool') {
              const oldCount = Array.isArray(oldValue) ? oldValue.length : 'undefined';
              const newCount = Array.isArray(newValue) ? newValue.length : 'undefined';

              // Enhanced debugging for drone name extraction
              let oldNames, newNames;

              if (Array.isArray(oldValue)) {
                try {
                  oldNames = oldValue.map(d => d?.name || 'UNNAMED').join(',');
                } catch (e) {
                  oldNames = `ERROR_MAPPING_OLD: ${e.message}`;
                }
              } else {
                oldNames = 'undefined';
              }

              if (Array.isArray(newValue)) {
                try {
                  newNames = newValue.map(d => d?.name || 'UNNAMED').join(',');
                } catch (e) {
                  newNames = `ERROR_MAPPING_NEW: ${e.message}`;
                }
              } else {
                newNames = 'undefined';
              }

              debugLog('STATE_SYNC', `  ü§ñ ${prop}: [${oldCount} drones] ‚Üí [${newCount} drones]`);
              debugLog('STATE_SYNC', `    Old drones: ${oldNames}`);
              debugLog('STATE_SYNC', `    New drones: ${newNames}`);

              // Additional debug info if there's an issue
              if (newNames.includes('ERROR') || newNames === 'undefined') {
                debugLog('STATE_SYNC', `    üîç Debug newValue:`, newValue);
                if (Array.isArray(newValue) && newValue.length > 0) {
                  debugLog('STATE_SYNC', `    üîç First drone object:`, newValue[0]);
                }
              }

              // Track source of activeDronePool updates for debugging
              if (oldCount !== newCount || oldNames !== newNames) {
                const stack = new Error().stack?.split('\n').slice(1, 4).join('\n') || 'No stack trace';
                debugLog('STATE_SYNC', `    üìç Update source:\n${stack}`);
              }
            } else if (prop === 'hand' || prop === 'deck') {
              const oldCount = Array.isArray(oldValue) ? oldValue.length : 'undefined';
              const newCount = Array.isArray(newValue) ? newValue.length : 'undefined';
              debugLog('STATE_SYNC', `  üÉè ${prop}: [${oldCount} cards] ‚Üí [${newCount} cards]`);
            } else if (prop === 'dronesOnBoard') {
              const oldLaneCounts = oldValue ? `L1:${oldValue.lane1?.length || 0} L2:${oldValue.lane2?.length || 0} L3:${oldValue.lane3?.length || 0}` : 'undefined';
              const newLaneCounts = newValue ? `L1:${newValue.lane1?.length || 0} L2:${newValue.lane2?.length || 0} L3:${newValue.lane3?.length || 0}` : 'undefined';
              debugLog('STATE_SYNC', `  üõ∏ ${prop}: ${oldLaneCounts} ‚Üí ${newLaneCounts}`);
            } else {
              debugLog('STATE_SYNC', `  üìù ${prop}:`, { before: oldValue, after: newValue });
            }
          }
        });

        debugLog('STATE_SYNC', `üîç Full ${playerId} state:`, newPlayer);
      }
    });
  }

  /**
   * Check if current phase is initialization/setup phase
   */
  isInitializationPhase(turnPhase) {
    const initPhases = [
      null,
      'preGame',
      'droneSelection',
      'deckSelection',
      'deckBuilding',
      'placement',
      'gameInitializing',
      'initialDraw'
    ];
    return initPhases.includes(turnPhase);
  }

  /**
   * Validate that appropriate functions are updating game state
   */
  validateFunctionAppropriateForStateUpdate(updates, prevState, isFromActionProcessor, stack) {
    // Skip validation during initialization phases
    if (this.isInitializationPhase(prevState.turnPhase)) {
      return;
    }

    // Skip if already validated as ActionProcessor update
    if (isFromActionProcessor) {
      return;
    }

    // Extract function names from stack trace
    const stackLines = stack?.split('\n') || [];
    const callerInfo = this.extractCallerInfo(stackLines);

    // Define functions that should NOT be updating game state
    const inappropriateFunctions = [
      // UI Event Handlers that should use ActionProcessor instead
      'handle',           // Generic event handlers (handleClick, handleSubmit, etc.)
      'onClick',          // Click handlers
      'onSubmit',         // Form handlers
      'onSelect',         // Selection handlers
      'onConfirm',        // Confirmation handlers
      'onComplete',       // Completion handlers

      // UI Component Functions
      'render',           // Rendering functions
      'component',        // Generic component functions
      'modal',            // Modal-related functions
      'display',          // Display functions
      'show',             // Show/hide functions
      'hide',             // Show/hide functions

      // UI State Management
      'setModal',         // UI modal state
      'setSelected',      // UI selection state
      'setActive',        // UI active state
      'setVisible',       // UI visibility state

      // Non-game Logic Functions
      'calculate',        // Calculation functions (should be pure)
      'format',           // Formatting functions
      'validate',         // Validation functions (should be pure)
      'transform',        // Data transformation functions
    ];

    // Define functions that ARE allowed to update game state
    const appropriateFunctions = [
      // Core game state management
      'GameStateManager',     // Direct GameStateManager methods
      'ActionProcessor',      // ActionProcessor methods
      'gameLogic',           // Game logic functions
      'gameEngine',          // Game engine functions

      // Setup and initialization
      'reset',               // Reset operations
      'initialize',          // Initialization functions
      'setup',               // Setup functions
      'init',                // Init functions

      // Internal state management
      'setState',            // Direct setState calls (allowed for internal operations)
      'updateState',         // Internal state updates
      'syncState',           // State synchronization

      // P2P and network operations
      'p2p',                 // P2P operations
      'network',             // Network operations
      'sync',                // Synchronization operations
    ];

    // Check if any inappropriate functions are in the call stack
    const inappropriateCallers = callerInfo.functions.filter(func =>
      inappropriateFunctions.some(inappropriate =>
        func.toLowerCase().includes(inappropriate.toLowerCase())
      )
    );

    // Check if any appropriate functions are in the call stack
    const appropriateCallers = callerInfo.functions.filter(func =>
      appropriateFunctions.some(appropriate =>
        func.toLowerCase().includes(appropriate.toLowerCase())
      )
    );

    // Only flag if we have inappropriate callers and no appropriate ones
    if (inappropriateCallers.length > 0 && appropriateCallers.length === 0) {
      console.warn('üö® Inappropriate function updating game state:', {
        inappropriateFunctions: inappropriateCallers,
        updates: Object.keys(updates),
        turnPhase: prevState.turnPhase,
        callerInfo: callerInfo,
        recommendation: 'UI functions should use processAction() instead of direct state updates',
        architecture: 'UI ‚Üí ActionProcessor ‚Üí gameLogic.js ‚Üí GameStateManager'
      });

      // Log detailed debug information
      console.debug('üîç Function validation debug info:', {
        allFunctionsInStack: callerInfo.functions,
        inappropriateFound: inappropriateCallers,
        appropriateFound: appropriateCallers,
        updateDetails: updates,
        stackTrace: stackLines.slice(0, 10)
      });
    }
  }

  /**
   * Extract caller information from stack trace
   */
  extractCallerInfo(stackLines) {
    const functions = [];
    const files = [];

    for (const line of stackLines) {
      // Extract function names - look for patterns like "at functionName (" or "at Object.functionName ("
      const functionMatch = line.match(/at\s+([\w.$]+)\s*\(/);
      if (functionMatch) {
        const funcName = functionMatch[1];
        // Filter out generic names and keep meaningful function names
        if (funcName !== 'Object' && funcName !== 'anonymous' && !funcName.startsWith('eval')) {
          functions.push(funcName);
        }
      }

      // Extract file names
      const fileMatch = line.match(/\/([^\/]+\.(jsx?|ts|tsx)):\d+/);
      if (fileMatch) {
        files.push(fileMatch[1]);
      }
    }

    return {
      functions: [...new Set(functions)], // Remove duplicates
      files: [...new Set(files)],         // Remove duplicates
      primaryCaller: functions[0] || 'Unknown',
      primaryFile: files[0] || 'Unknown'
    };
  }

  /**
   * Validate ownership boundaries - each manager should only update fields it owns
   */
  validateOwnershipBoundaries(updates, stack) {
    if (!stack) return;

    const updateKeys = Object.keys(updates);
    if (updateKeys.length === 0) return;

    // Manager identification from stack
    // Use context flag first (production-safe) then fall back to stack trace (dev-only)
    const isGameFlowManager = this._updateContext === 'GameFlowManager' || stack.includes('GameFlowManager');
    const isSequentialPhaseManager = this._updateContext === 'SequentialPhaseManager' || stack.includes('SequentialPhaseManager');
    const isActionProcessor = this._updateContext === 'ActionProcessor' || stack.includes('ActionProcessor');

    // Define ownership boundaries
    const ownershipRules = {
      // GameFlowManager owns orchestration
      'turnPhase': 'GameFlowManager',
      'gameStage': 'GameFlowManager',
      'roundNumber': 'GameFlowManager',
      'gameActive': 'GameFlowManager',

      // SequentialPhaseManager owns pass state during sequential phases
      // GameFlowManager can reset passInfo at round boundaries
      'passInfo': ['SequentialPhaseManager', 'GameFlowManager'],

      // ActionProcessor can update currentPlayer for turn transitions within phase
      // GameFlowManager can update currentPlayer for phase-to-phase transitions
      'currentPlayer': ['ActionProcessor', 'GameFlowManager'],

      // First player determination fields - ActionProcessor handles first player determination results
      'firstPlayerOfRound': ['ActionProcessor', 'GameFlowManager'],
      'firstPlayerOverride': ['ActionProcessor', 'GameFlowManager']
    };

    // Check each update against ownership rules
    for (const updateKey of updateKeys) {
      const allowedOwners = ownershipRules[updateKey];
      if (!allowedOwners) continue; // No ownership rule defined

      const allowedOwnersList = Array.isArray(allowedOwners) ? allowedOwners : [allowedOwners];

      let hasPermission = false;
      for (const allowedOwner of allowedOwnersList) {
        if (allowedOwner === 'GameFlowManager' && isGameFlowManager) hasPermission = true;
        else if (allowedOwner === 'SequentialPhaseManager' && isSequentialPhaseManager) hasPermission = true;
        else if (allowedOwner === 'ActionProcessor' && isActionProcessor) hasPermission = true;
      }

      if (!hasPermission) {
        const currentManager = isGameFlowManager ? 'GameFlowManager' :
                             isSequentialPhaseManager ? 'SequentialPhaseManager' :
                             isActionProcessor ? 'ActionProcessor' : 'Unknown';

        console.warn(`üö® OWNERSHIP VIOLATION: ${currentManager} cannot update '${updateKey}'`, {
          updateKey,
          currentManager,
          allowedOwners: allowedOwnersList,
          updates: updateKeys,
          recommendation: `Only ${allowedOwnersList.join(' or ')} should update '${updateKey}'`
        });
      }
    }
  }

  // --- GAME STATE METHODS ---

  /**
   * Validate that game state is clean before starting a new game
   * @returns {{ valid: boolean, issues: string[] }} Validation result
   */
  validatePreGameState() {
    const issues = [];

    if (this.state.gameStage !== 'preGame') {
      issues.push(`gameStage is '${this.state.gameStage}' (expected 'preGame')`);
    }
    if (this.state.roundNumber !== 0) {
      issues.push(`roundNumber is ${this.state.roundNumber} (expected 0)`);
    }
    if (this.state.gameActive) {
      issues.push('gameActive is true (expected false)');
    }
    if (this.state.player1 !== null) {
      issues.push('player1 is not null');
    }
    if (this.state.player2 !== null) {
      issues.push('player2 is not null');
    }
    if (this.state.turnPhase !== null) {
      issues.push(`turnPhase is '${this.state.turnPhase}' (expected null)`);
    }
    if (tacticalMapStateManager.isRunActive()) {
      issues.push('TacticalMapStateManager has active run (orphaned single-player run)');
    }
    if (this.state.singlePlayerEncounter !== null) {
      issues.push('singlePlayerEncounter is not null');
    }
    if (this.state.winner !== null) {
      issues.push(`winner is '${this.state.winner}' (expected null)`);
    }
    if (this.state.commitments && Object.keys(this.state.commitments).length > 0) {
      issues.push('commitments object is not empty');
    }

    if (issues.length > 0) {
      debugLog('STATE_SYNC', '‚ö†Ô∏è Pre-game state validation failed:', issues);
      return { valid: false, issues };
    }
    return { valid: true, issues: [] };
  }

  /**
   * Validate that state is clean before starting a single-player run
   * @returns {{ valid: boolean, issues: string[] }} Validation result
   */
  validatePreRunState() {
    const issues = [];

    if (tacticalMapStateManager.isRunActive()) {
      issues.push('TacticalMapStateManager has active run (run already in progress)');
    }
    if (this.state.singlePlayerEncounter !== null) {
      issues.push('singlePlayerEncounter is not null');
    }
    if (this.state.gameActive) {
      issues.push('gameActive is true (PvP game in progress)');
    }

    if (issues.length > 0) {
      debugLog('STATE_SYNC', '‚ö†Ô∏è Pre-run state validation failed:', issues);
      return { valid: false, issues };
    }
    return { valid: true, issues: [] };
  }

  /**
   * Clear single-player context (run state and encounter) without clearing profile/inventory
   * Call this before starting PvP games to clean up orphaned SP state
   */
  clearSinglePlayerContext() {
    debugLog('STATE_SYNC', 'üßπ Clearing single-player context');
    // End run in TacticalMapStateManager if active
    if (tacticalMapStateManager.isRunActive()) {
      tacticalMapStateManager.endRun();
    }
    this.setState({
      singlePlayerEncounter: null
    });
  }

  /**
   * Safely transition to a new app state with automatic cleanup
   * @param {string} newState - The new app state to transition to
   */
  transitionToAppState(newState) {
    // Clean up active game if navigating away to menu
    if (this.state.gameActive && newState === 'menu') {
      debugLog('STATE_SYNC', 'Active game detected during navigation, cleaning up');
      this.endGame();
    }

    // Clean up run state if navigating to menu
    if (tacticalMapStateManager.isRunActive() && newState === 'menu') {
      debugLog('STATE_SYNC', 'Active run detected during navigation, cleaning up');
      this.endRun(false); // Lost run
    }

    this.setState({ appState: newState });
  }

  /**
   * Reset game to initial state
   */
  reset() {
    debugLog('STATE_SYNC', 'üîÑ GAME RESET: Resetting game state and clearing caches');

    const initialState = {
      turnPhase: 'preGame',
      turn: 1,
      currentPlayer: null,
      actionsTakenThisTurn: 0,
      firstPlayerOfRound: null,
      firstPasserOfPreviousRound: null,
      firstPlayerOverride: null,
      passInfo: { firstPasser: null, player1Passed: false, player2Passed: false },
      winner: null,
      player1: gameEngine.initialPlayerState('Player 1', startingDecklist),
      player2: gameEngine.initialPlayerState('Player 2', startingDecklist),
      placedSections: [],
      opponentPlacedSections: [],
      unplacedSections: [],
      shieldsToAllocate: 0,
      droneSelectionPool: [],
      droneSelectionTrio: [],
      gameLog: [],

      // --- COMMITMENTS (for simultaneous phases) ---
      commitments: {},
    };

    this.setState(initialState, 'GAME_RESET');

    // Clear GameDataService singleton and cache to prevent stale data
    GameDataService.reset();

    // Clear ActionProcessor queue to prevent stale actions
    this.actionProcessor.clearQueue();
    // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
    this.gameFlowManager?.resubscribe();

    debugLog('STATE_SYNC', '‚úÖ GAME RESET: State, cache, and queue cleared');
  }

  /**
   * Start a new game session - initialize players and game state
   * @param {string} gameMode - 'local', 'host', 'guest'
   * @param {Object} player1Config - Player 1 configuration
   * @param {Object} player2Config - Player 2 configuration
   */
  startGame(gameMode = 'local', player1Config = {}, player2Config = {}) {
    debugLog('STATE_SYNC', 'üéÆ GAME START: Initializing new game session');

    // Clear any orphaned single-player context before starting PvP
    this.clearSinglePlayerContext();

    // Validate pre-game state and cleanup if dirty
    const validation = this.validatePreGameState();
    if (!validation.valid) {
      console.error(
        '=== DIRTY STATE DETECTED AT GAME START ===\n' +
        'Issues found:\n' +
        validation.issues.map(i => `  - ${i}`).join('\n') + '\n' +
        'Calling resetGameState() to clean up.\n' +
        'Stack trace:',
        new Error().stack
      );
      this.resetGameState();
    }

    // Generate random game seed for deterministic gameplay
    // Host/Local generates, Guest receives from first broadcast
    const gameSeed = gameMode === 'guest'
      ? null  // Guest will receive seed from Host
      : Math.floor(Math.random() * 2147483647);

    const gameState = {
      // Activate game
      appState: 'inGame',
      gameActive: true,
      gameMode: gameMode,
      gameSeed: gameSeed,

      // Initialize game flow
      turnPhase: 'deckSelection',
      turn: 1,
      gameStage: 'preGame',
      roundNumber: 0,
      currentPlayer: null,
      actionsTakenThisTurn: 0,
      firstPlayerOfRound: null,
      firstPasserOfPreviousRound: null,
      firstPlayerOverride: null,
      passInfo: { firstPasser: null, player1Passed: false, player2Passed: false },
      winner: null,

      // Initialize players with custom configurations
      player1: {
        ...gameEngine.initialPlayerState(
          player1Config.name || 'Player 1',
          player1Config.decklist || startingDecklist,
          'player1',
          gameSeed,  // Use same seed for both players
          player1Config.shipId || null  // Ship card ID (null = default)
        ),
        ...player1Config
      },
      player2: {
        ...gameEngine.initialPlayerState(
          player2Config.name || 'Player 2',
          player2Config.decklist || startingDecklist,
          'player2',
          gameSeed,  // Use same seed for both players
          player2Config.shipId || null  // Ship card ID (null = default)
        ),
        ...player2Config
      },

      // Initialize game components
      placedSections: [],
      opponentPlacedSections: [],
      unplacedSections: [],
      shieldsToAllocate: 0,
      gameLog: [],

      // --- COMMITMENTS (for simultaneous phases) ---
      commitments: {},

      // Drone selection data (will be initialized by GameFlowManager when transitioning to droneSelection)
      droneSelectionPool: [],
      droneSelectionTrio: [],
    };

    this.setState(gameState, 'GAME_STARTED');

    // Set up GameFlowManager subscription just before gameplay begins
    // This is the "just-in-time" initialization point for turn transitions
    // See: GameFlowManager.subscription.test.js for architectural documentation
    this.gameFlowManager?.resubscribe();

    debugLog('STATE_SYNC', 'üë§ Player 1 Created:', {
      name: gameState.player1.name,
      energy: gameState.player1.energy,
      deckCount: gameState.player1.deck?.length || 0
    });
    debugLog('STATE_SYNC', 'üë§ Player 2 Created:', {
      name: gameState.player2.name,
      energy: gameState.player2.energy,
      deckCount: gameState.player2.deck?.length || 0
    });
    debugLog('STATE_SYNC', '‚úÖ GAME START: Game session initialized successfully');
  }

  /**
   * End current game session - return to menu state
   */
  endGame() {
    debugLog('STATE_SYNC', 'üéÆ GAME END: Ending current game session and clearing caches');

    // Use canonical reset function for all game state cleanup
    this.resetGameState();

    // Set app state to menu (not part of game state reset)
    this.setState({
      appState: 'menu',
    }, 'GAME_ENDED');

    // Clear GameDataService singleton and cache to prevent stale data in new games
    GameDataService.reset();

    // Clear ActionProcessor queue to prevent stale actions
    this.actionProcessor.clearQueue();
    // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
    this.gameFlowManager?.resubscribe();

    // Reset GameFlowManager to clear phase state (includes PhaseManager.reset())
    if (this.gameFlowManager) {
      this.gameFlowManager.reset();
    }

    // Clean up AIPhaseProcessor (clear timers, unsubscribe from state changes)
    // This prevents stale subscriptions and timers from affecting the next game
    if (aiPhaseProcessor?.cleanup) {
      aiPhaseProcessor.cleanup();
      debugLog('STATE_SYNC', '‚úÖ AIPhaseProcessor cleaned up');
    }

    debugLog('STATE_SYNC', '‚úÖ GAME END: Returned to menu state, all singletons cleared');
  }

  /**
   * Initialize test mode game - bypasses normal game flow
   * @param {Object} testConfig - Test configuration from testGameInitializer
   * @returns {boolean} Success status
   */
  initializeTestMode(testConfig) {
    debugLog('STATE_SYNC', 'üß™ TEST MODE: Initializing test game from GameStateManager');

    // Import testGameInitializer dynamically to avoid circular dependencies
    import('../services/testGameInitializer.js').then(module => {
      const success = module.initializeTestGame(testConfig, this);

      if (success) {
        debugLog('STATE_SYNC', '‚úÖ TEST MODE: Test game initialized successfully');
      } else {
        debugLog('STATE_SYNC', '‚ùå TEST MODE: Test game initialization failed');
      }
    }).catch(error => {
      console.error('‚ùå TEST MODE: Error importing testGameInitializer:', error);
    });

    return true; // Return immediately, actual initialization happens asynchronously
  }

  /**
   * Set multiplayer mode and role
   */
  setMultiplayerMode(mode, isHost = false) {
    this.setState({
      gameMode: mode,
    }, 'MULTIPLAYER_MODE_SET');
  }

  /**
   * Update player states
   */
  updatePlayers(player1Updates = {}, player2Updates = {}) {
    const updates = {};
    if (Object.keys(player1Updates).length > 0) {
      updates.player1 = { ...this.state.player1, ...player1Updates };
    }
    if (Object.keys(player2Updates).length > 0) {
      updates.player2 = { ...this.state.player2, ...player2Updates };
    }

    if (Object.keys(updates).length > 0) {
      this.setState(updates, 'PLAYERS_UPDATED');
    }
  }

  /**
   * Update specific player state directly
   */
  updatePlayerState(playerId, updates) {
    if (playerId === 'player1') {
      this.updatePlayers(updates, {});
    } else if (playerId === 'player2') {
      this.updatePlayers({}, updates);
    }
  }

  /**
   * Set player states directly (for gameLogic integration)
   */
  setPlayerStates(newPlayer1, newPlayer2) {
    this.setState({
      player1: newPlayer1,
      player2: newPlayer2
    }, 'PLAYER_STATES_SET');

    // DEBUG: Log event emission timing
    debugLog('RESOURCE_RESET', `üîî [GAMESTATEMANAGER] PLAYER_STATES_SET event emitted`, {
      timestamp: Date.now(),
      player1Energy: newPlayer1.energy,
      player1DeploymentBudget: newPlayer1.deploymentBudget,
      player2Energy: newPlayer2.energy,
      player2DeploymentBudget: newPlayer2.deploymentBudget
    });
  }

  /**
   * Set current player
   */
  setCurrentPlayer(playerId) {
    debugLog('TURN_TRANSITION_DEBUG', 'setCurrentPlayer called', {
      newPlayerId: playerId,
      previousPlayer: this.state.currentPlayer,
      subscriberCount: this.listeners.size
    });
    this.setState({ currentPlayer: playerId }, 'CURRENT_PLAYER_CHANGED');
  }

  /**
   * Set turn phase
   */
  setTurnPhase(phase) {
    this.setState({ turnPhase: phase }, 'TURN_PHASE_CHANGED');
  }

  /**
   * Set first player of round
   */
  setFirstPlayerOfRound(playerId) {
    this.setState({ firstPlayerOfRound: playerId }, 'FIRST_PLAYER_OF_ROUND_SET');
  }

  /**
   * Set first passer of previous round
   */
  setFirstPasserOfPreviousRound(playerId) {
    this.setState({ firstPasserOfPreviousRound: playerId }, 'FIRST_PASSER_OF_PREVIOUS_ROUND_SET');
  }

  /**
   * Set first player override
   */
  setFirstPlayerOverride(playerId) {
    this.setState({ firstPlayerOverride: playerId }, 'FIRST_PLAYER_OVERRIDE_SET');
  }

  /**
   * Update pass information
   */
  updatePassInfo(passUpdates) {
    const updatedPassInfo = { ...this.state.passInfo, ...passUpdates };
    this.setState({ passInfo: updatedPassInfo }, 'PASS_INFO_UPDATED');
  }

  /**
   * Set pass information directly
   */
  setPassInfo(passInfo) {
    this.setState({ passInfo: passInfo }, 'PASS_INFO_SET');
  }

  /**
   * Check if it's the local player's turn (for multiplayer)
   */
  isMyTurn() {
    // In local mode, player1 is the human player
    if (this.state.gameMode === 'local') return this.state.currentPlayer === 'player1';
    if (this.state.gameMode === 'host') return this.state.currentPlayer === 'player1';
    if (this.state.gameMode === 'guest') return this.state.currentPlayer === 'player2';
    return false;
  }

  /**
   * Get local player ID based on role
   */
  getLocalPlayerId() {
    if (this.state.gameMode === 'local') return 'player1'; // For local AI games
    if (this.state.gameMode === 'host') return 'player1';
    if (this.state.gameMode === 'guest') return 'player2';
    return 'player1';
  }

  /**
   * Get opponent player ID
   */
  getOpponentPlayerId() {
    const localId = this.getLocalPlayerId();
    return localId === 'player1' ? 'player2' : 'player1';
  }

  /**
   * Get local player state object
   */
  getLocalPlayerState() {
    const localId = this.getLocalPlayerId();
    return this.state[localId];
  }

  /**
   * Get opponent player state object
   */
  getOpponentPlayerState() {
    const opponentId = this.getOpponentPlayerId();
    return this.state[opponentId];
  }

  /**
   * Check if a given player ID is the local player (for UI perspective)
   */
  isLocalPlayer(playerId) {
    return playerId === this.getLocalPlayerId();
  }

  /**
   * Get placed sections for local player (UI perspective)
   */
  getLocalPlacedSections() {
    if (this.state.gameMode === 'local') return this.state.placedSections;
    if (this.state.gameMode === 'host') return this.state.placedSections;
    if (this.state.gameMode === 'guest') return this.state.opponentPlacedSections;
    return this.state.placedSections;
  }

  /**
   * Get placed sections for opponent (UI perspective)
   */
  getOpponentPlacedSections() {
    let result;
    if (this.state.gameMode === 'local') result = this.state.opponentPlacedSections;
    else if (this.state.gameMode === 'host') result = this.state.opponentPlacedSections;
    else if (this.state.gameMode === 'guest') result = this.state.placedSections;
    else result = this.state.opponentPlacedSections;

    // Only debug during placement phase when there's actual data
    if (this.state.turnPhase === 'placement' && result.some(s => s !== null)) {
      debugLog('STATE_SYNC', 'üîç [DEBUG] GameStateManager.getOpponentPlacedSections:', {
        gameMode: this.state.gameMode,
        result,
        rawOpponentPlacedSections: this.state.opponentPlacedSections,
        rawPlacedSections: this.state.placedSections
      });
    }

    return result;
  }

  /**
   * Track optimistic animations for fine-grained deduplication (guest mode)
   * Used to prevent duplicate animations when host echoes back guest's action
   * @param {Object} animations - {actionAnimations: [], systemAnimations: []}
   */
  trackOptimisticAnimations(animations) {
    this.optimisticActionService.trackAction(animations);
  }

  /**
   * Filter incoming animations to remove duplicates
   * Used by GuestMessageQueueService when processing host responses
   * @param {Array} actionAnimations - Action animations from host
   * @param {Array} systemAnimations - System animations from host
   * @returns {Object} - {actionAnimations: [], systemAnimations: []}
   */
  filterAnimations(actionAnimations, systemAnimations) {
    return this.optimisticActionService.filterAnimations(actionAnimations, systemAnimations);
  }

  /**
   * Check if we have tracked optimistic animations
   * Used by GuestMessageQueueService to determine filtering strategy
   */
  hasRecentOptimisticActions() {
    const status = this.optimisticActionService.getStatus();
    return status.actionAnimationsTracked > 0 || status.systemAnimationsTracked > 0;
  }

  /**
   * Clear all tracked optimistic animations
   */
  clearOptimisticActions() {
    this.optimisticActionService.clearTrackedAnimations();
  }

  /**
   * Add log entry
   */
  addLogEntry(entry, debugSource = null, aiDecisionContext = null) {
    // Merge debugSource and aiDecisionContext into the entry object
    const enhancedEntry = {
      ...entry,
      timestamp: entry.timestamp || Date.now(),
      round: entry.round || this.state.turn
    };

    // Add debugSource if provided
    if (debugSource) {
      enhancedEntry.debugSource = debugSource;
    }

    // Add aiDecisionContext if provided
    if (aiDecisionContext) {
      enhancedEntry.aiDecisionContext = aiDecisionContext;
    }

    const updatedLog = [...this.state.gameLog, enhancedEntry];
    this.setState({ gameLog: updatedLog }, 'LOG_ENTRY_ADDED');
  }

  /**
   * Add AI decision to history for CSV export
   * @param {string} phase - Decision phase (deployment, action, interception)
   * @param {number} turn - Turn number
   * @param {Array} possibleActions - Array of all evaluated actions
   * @param {Object} gameState - Current game state snapshot
   */
  addAIDecisionToHistory(phase, turn, possibleActions, gameState) {
    // Create decision entry
    const decisionEntry = {
      phase,
      turn,
      timestamp: new Date().toISOString(),
      decisions: possibleActions.map(action => ({
        type: action.type,
        instigator: action.instigator,
        targetName: action.targetName,
        score: action.score,
        logic: action.logic || [],
        isChosen: action.isChosen || false
      })),
      gameState: {
        player1: {
          energy: gameState?.player1?.energy,
          dronesOnBoard: gameState?.player1?.dronesOnBoard
        },
        player2: {
          energy: gameState?.player2?.energy,
          dronesOnBoard: gameState?.player2?.dronesOnBoard
        }
      }
    };

    const updatedHistory = [...this.state.aiDecisionHistory, decisionEntry];
    this.setState({ aiDecisionHistory: updatedHistory }, 'AI_DECISION_ADDED');
  }

  /**
   * Update pass information
   */
  updatePassInfo(passUpdates) {
    const updatedPassInfo = { ...this.state.passInfo, ...passUpdates };
    this.setState({ passInfo: updatedPassInfo }, 'PASS_INFO_UPDATED');
  }

  /**
   * Set winner
   * For single-player extraction mode, processes combat outcome (victory/defeat)
   */
  setWinner(winnerId) {
    // Check if this is single-player extraction mode combat
    const currentState = this.getState();
    if (currentState.gameMode === 'singlePlayer' && tacticalMapStateManager.isRunActive()) {
      debugLog('SP_COMBAT', `Single-player combat ended. Winner: ${winnerId}`);

      // Just set winner - WinnerModal will handle transition via button click
      // CombatOutcomeProcessor.processCombatEnd() is called from WinnerModal
      this.setState({ winner: winnerId }, 'GAME_ENDED');
      return;
    }

    // Standard multiplayer/local mode
    this.setState({ winner: winnerId }, 'GAME_ENDED');
  }

  // --- ACTION PROCESSING ---

  /**
   * Process a game action through the action queue
   * @param {string} actionType - Type of action (attack, ability, deployment, etc.)
   * @param {Object} payload - Action-specific data
   * @returns {Promise} Resolves when action is complete
   */
  async processAction(actionType, payload) {
    return await this.actionProcessor.queueAction({
      type: actionType,
      payload: payload
    });
  }

  /**
   * Check if any actions are currently being processed
   */
  isActionInProgress() {
    return this.actionProcessor.isActionInProgress();
  }

  /**
   * Get current action queue length
   */
  getActionQueueLength() {
    return this.actionProcessor.getQueueLength();
  }

  /**
   * Emergency action queue clear (use with caution)
   */
  clearActionQueue() {
    this.actionProcessor.clearQueue();
    // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
    this.gameFlowManager?.resubscribe();
  }

  // ========================================
  // SINGLE-PLAYER (EXTRACTION MODE) METHODS
  // ========================================

  /**
   * Create new single-player profile
   * Initializes a new save with default values
   */
  createNewSinglePlayerProfile() {
    const newSave = createNewSave();
    this.loadSinglePlayerSave(newSave);
    console.log('New single-player profile created');
  }

  /**
   * Load single-player save
   * @param {Object} saveData - Save data to load
   */
  loadSinglePlayerSave(saveData) {
    // Migration: Calculate highestUnlockedSlot for saves without it
    const profile = { ...saveData.playerProfile };
    if (profile.highestUnlockedSlot === undefined) {
      // Find highest slot that has a deck (active or mia status)
      const activeSlotIds = (saveData.shipSlots || [])
        .filter(s => s.id > 0 && s.status !== 'empty')
        .map(s => s.id);
      profile.highestUnlockedSlot = activeSlotIds.length > 0 ? Math.max(...activeSlotIds) : 0;
      console.log(`Migration: Set highestUnlockedSlot to ${profile.highestUnlockedSlot}`);
    }

    // Migration: Generate shop pack if not present (new saves and old saves)
    if (!profile.shopPack) {
      const highestTier = profile.stats?.highestTierCompleted || 0;
      profile.shopPack = generateRandomShopPack(highestTier, Date.now());
      console.log('Migration: Generated shop pack:', profile.shopPack);
    }

    this.setState({
      singlePlayerProfile: profile,
      singlePlayerInventory: saveData.inventory,
      singlePlayerDroneInstances: saveData.droneInstances,
      singlePlayerShipComponentInstances: saveData.shipComponentInstances,
      singlePlayerDiscoveredCards: saveData.discoveredCards,
      singlePlayerShipSlots: saveData.shipSlots,
      quickDeployments: saveData.quickDeployments || [],  // Backwards compat default
    });

    // Load run state to TacticalMapStateManager if present
    if (saveData.currentRunState) {
      tacticalMapStateManager.loadFromSave(saveData.currentRunState);
      console.log('Run state loaded to TacticalMapStateManager');
    }

    console.log('Single-player save loaded');
  }

  /**
   * Get current save data for serialization
   * @returns {Object} Save data
   */
  getSaveData() {
    return {
      playerProfile: this.state.singlePlayerProfile,
      inventory: this.state.singlePlayerInventory,
      droneInstances: this.state.singlePlayerDroneInstances,
      shipComponentInstances: this.state.singlePlayerShipComponentInstances,
      discoveredCards: this.state.singlePlayerDiscoveredCards,
      shipSlots: this.state.singlePlayerShipSlots,
      currentRunState: tacticalMapStateManager.getState(),  // Get from TacticalMapStateManager
      quickDeployments: this.state.quickDeployments || [],
    };
  }

  /**
   * Update card discovery state
   * @param {string} cardId - Card ID
   * @param {string} newState - New state: 'owned' | 'discovered' | 'undiscovered'
   */
  updateCardDiscoveryState(cardId, newState) {
    const validStates = ['owned', 'discovered', 'undiscovered'];
    if (!validStates.includes(newState)) {
      throw new Error(`Invalid discovery state: ${newState}`);
    }

    const discoveredCards = [...this.state.singlePlayerDiscoveredCards];
    const index = discoveredCards.findIndex(entry => entry.cardId === cardId);

    if (index >= 0) {
      discoveredCards[index] = { ...discoveredCards[index], state: newState };
    } else {
      // Add new entry if card doesn't exist
      discoveredCards.push({ cardId, state: newState });
    }

    this.setState({ singlePlayerDiscoveredCards: discoveredCards });
    console.log(`Card ${cardId} discovery state updated to ${newState}`);
  }

  /**
   * Add card to discovered cards when unlocked from pack
   * @param {string} cardId - Card ID
   */
  addDiscoveredCard(cardId) {
    this.updateCardDiscoveryState(cardId, 'discovered');
  }

  /**
   * Add card to inventory (from loot, crafting, etc.)
   * @param {string} cardId - Card ID
   * @param {number} quantity - Quantity to add (default 1)
   */
  addToInventory(cardId, quantity = 1) {
    const newInventory = {
      ...this.state.singlePlayerInventory,
      [cardId]: (this.state.singlePlayerInventory[cardId] || 0) + quantity
    };

    this.setState({ singlePlayerInventory: newInventory });

    // Also mark as owned in discovery
    this.updateCardDiscoveryState(cardId, 'owned');

    console.log(`Added ${quantity}x ${cardId} to inventory`);
  }

  /**
   * Add ship component instance
   * @param {Object} instance - Component instance { instanceId, componentId, shipSlotId, currentHull, maxHull }
   */
  addShipComponentInstance(instance) {
    const instances = [...this.state.singlePlayerShipComponentInstances];
    instances.push(instance);
    this.setState({ singlePlayerShipComponentInstances: instances });
    console.log('Ship component instance added:', instance);
  }

  /**
   * Update ship component hull
   * @param {string} instanceId - Instance ID
   * @param {number} newHull - New hull value
   */
  updateShipComponentHull(instanceId, newHull) {
    const instances = [...this.state.singlePlayerShipComponentInstances];
    const index = instances.findIndex(inst => inst.instanceId === instanceId);

    if (index >= 0) {
      instances[index] = { ...instances[index], currentHull: newHull };
      this.setState({ singlePlayerShipComponentInstances: instances });
      console.log(`Ship component ${instanceId} hull updated to ${newHull}`);
    } else {
      console.warn(`Ship component instance ${instanceId} not found`);
    }
  }

  /**
   * Get ship component instance
   * @param {string} instanceId - Instance ID
   * @returns {Object|null} Component instance or null if not found
   */
  getShipComponentInstance(instanceId) {
    return this.state.singlePlayerShipComponentInstances.find(inst => inst.instanceId === instanceId) || null;
  }

  // ========================================
  // TACTICAL ITEMS METHODS
  // ========================================

  /**
   * Purchase a tactical item
   * @param {string} itemId - The item ID (e.g., 'ITEM_EVADE')
   * @returns {Object} { success: boolean, newQuantity?: number, error?: string }
   */
  purchaseTacticalItem(itemId) {
    const item = getTacticalItemById(itemId);

    if (!item) {
      return { success: false, error: 'Item not found' };
    }

    const profile = this.state.singlePlayerProfile;

    if (profile.credits < item.cost) {
      return { success: false, error: 'Insufficient credits' };
    }

    const currentQty = profile.tacticalItems?.[itemId] || 0;

    if (currentQty >= item.maxCapacity) {
      return { success: false, error: `Already at max capacity (${item.maxCapacity})` };
    }

    const newQuantity = currentQty + 1;

    this.setState({
      singlePlayerProfile: {
        ...profile,
        credits: profile.credits - item.cost,
        tacticalItems: {
          ...profile.tacticalItems,
          [itemId]: newQuantity
        }
      }
    });

    console.log(`Purchased ${item.name} for ${item.cost} credits. Now have ${newQuantity}`);

    return { success: true, newQuantity };
  }

  /**
   * Purchase the currently available shop card pack
   * @returns {Object} { success: boolean, cards?: Array, cost?: number, error?: string }
   */
  purchaseCardPack() {
    const profile = this.state.singlePlayerProfile;
    const shopPack = profile?.shopPack;

    if (!shopPack) {
      return { success: false, error: 'No pack available' };
    }

    const { packType, tier, seed } = shopPack;
    const cost = getPackCostForTier(tier);

    if (profile.credits < cost) {
      return { success: false, error: 'Insufficient credits' };
    }

    // Generate pack contents using seeded RNG for deterministic results
    const result = rewardManager.generateShopPack(packType, tier, seed);

    if (!result.cards || result.cards.length === 0) {
      return { success: false, error: 'Failed to generate cards' };
    }

    // Deduct credits
    const newCredits = profile.credits - cost;

    // Add cards to inventory
    const newInventory = { ...this.state.singlePlayerInventory };
    result.cards.forEach(card => {
      newInventory[card.cardId] = (newInventory[card.cardId] || 0) + 1;
    });

    // Clear shop pack (consumed) and update state
    this.setState({
      singlePlayerProfile: {
        ...profile,
        credits: newCredits,
        shopPack: null // Pack consumed
      },
      singlePlayerInventory: newInventory
    });

    console.log(`Purchased ${packType} T${tier} for ${cost} credits. Cards:`, result.cards.map(c => c.cardId));

    return { success: true, cards: result.cards, cost };
  }

  /**
   * Use a tactical item (during a run)
   * @param {string} itemId - The item ID
   * @returns {Object} { success: boolean, remaining?: number, error?: string }
   */
  useTacticalItem(itemId) {
    const profile = this.state.singlePlayerProfile;
    const currentQty = profile.tacticalItems?.[itemId] || 0;

    if (currentQty <= 0) {
      return { success: false, error: 'No items available' };
    }

    const remaining = currentQty - 1;

    this.setState({
      singlePlayerProfile: {
        ...profile,
        tacticalItems: {
          ...profile.tacticalItems,
          [itemId]: remaining
        }
      }
    });

    console.log(`Used tactical item ${itemId}. Remaining: ${remaining}`);

    return { success: true, remaining };
  }

  /**
   * Get the current count of a tactical item
   * @param {string} itemId - The item ID
   * @returns {number} The current quantity (0 if not found)
   */
  getTacticalItemCount(itemId) {
    return this.state.singlePlayerProfile?.tacticalItems?.[itemId] || 0;
  }

  // ========================================
  // DECK MANAGEMENT METHODS
  // ========================================

  /**
   * Set default ship slot for deployment
   * @param {number} slotId - Slot ID (0-5)
   */
  setDefaultShipSlot(slotId) {
    if (slotId < 0 || slotId > 5) {
      throw new Error('Invalid slot ID: must be 0-5');
    }

    const slot = this.state.singlePlayerShipSlots.find(s => s.id === slotId);
    if (!slot || slot.status !== 'active') {
      throw new Error(`Slot ${slotId} is not active`);
    }

    const updatedProfile = {
      ...this.state.singlePlayerProfile,
      defaultShipSlotId: slotId
    };

    this.setState({ singlePlayerProfile: updatedProfile });
    console.log(`Default ship slot set to ${slotId}`);
  }

  /**
   * Check if a deck slot is unlocked
   * @param {number} slotId - Slot ID (0-5)
   * @returns {boolean} True if slot is unlocked
   */
  isSlotUnlocked(slotId) {
    const highestUnlocked = this.state.singlePlayerProfile?.highestUnlockedSlot ?? 0;
    return slotId <= highestUnlocked;
  }

  /**
   * Get the next slot available for unlocking
   * @returns {Object|null} { slotId, cost } or null if all unlocked
   */
  getNextUnlockableSlot() {
    const highestUnlocked = this.state.singlePlayerProfile?.highestUnlockedSlot ?? 0;
    const nextSlotId = highestUnlocked + 1;
    if (nextSlotId > 5) return null;
    return {
      slotId: nextSlotId,
      cost: ECONOMY.DECK_SLOT_UNLOCK_COSTS[nextSlotId],
    };
  }

  /**
   * Unlock the next deck slot (sequential unlocking enforced)
   * Deducts credits from player profile
   * @returns {Object} { success: boolean, slotId?: number, error?: string }
   */
  unlockNextDeckSlot() {
    const profile = this.state.singlePlayerProfile;
    const currentHighest = profile.highestUnlockedSlot ?? 0;
    const nextSlotId = currentHighest + 1;

    // Check if all slots already unlocked
    if (nextSlotId > 5) {
      return { success: false, error: 'All deck slots are already unlocked' };
    }

    // Get cost for next slot
    const cost = ECONOMY.DECK_SLOT_UNLOCK_COSTS[nextSlotId];

    // Check if player has enough credits
    if (profile.credits < cost) {
      return {
        success: false,
        error: `Insufficient credits. Need ${cost}, have ${profile.credits}`,
      };
    }

    // Deduct credits and unlock slot
    const updatedProfile = {
      ...profile,
      credits: profile.credits - cost,
      highestUnlockedSlot: nextSlotId,
    };

    this.setState({ singlePlayerProfile: updatedProfile });
    console.log(`Unlocked deck slot ${nextSlotId} for ${cost} credits`);
    return { success: true, slotId: nextSlotId };
  }

  /**
   * Save deck data to a ship slot
   * @param {number} slotId - Slot ID (1-5, cannot modify 0)
   * @param {Object} deckData - { name, decklist, droneSlots, drones, shipComponents, shipId }
   */
  saveShipSlotDeck(slotId, deckData) {
    if (slotId === 0) {
      throw new Error('Cannot modify Slot 0 (immutable starter deck)');
    }

    const { name, decklist, droneSlots, drones, shipComponents, shipId } = deckData;
    const slots = [...this.state.singlePlayerShipSlots];
    const slotIndex = slots.findIndex(s => s.id === slotId);

    if (slotIndex === -1) {
      throw new Error(`Slot ${slotId} not found`);
    }

    // Clear old instances for this slot
    this.clearSlotInstances(slotId);

    // Preserve existing sectionSlots OR convert from shipComponents
    // This ensures componentIds are properly populated for damage persistence
    let existingSectionSlots = slots[slotIndex].sectionSlots
      || convertComponentsToSectionSlots(shipComponents);

    // Update componentIds from shipComponents while preserving damageDealt
    if (shipComponents) {
      existingSectionSlots = { ...existingSectionSlots };
      Object.entries(shipComponents).forEach(([componentId, lane]) => {
        if (existingSectionSlots[lane]) {
          existingSectionSlots[lane] = {
            ...existingSectionSlots[lane],
            componentId
          };
        }
      });
    }

    slots[slotIndex] = {
      ...slots[slotIndex],
      name: name || `Ship ${slotId}`,
      decklist,
      // New format: droneSlots is the source of truth
      droneSlots: droneSlots || slots[slotIndex].droneSlots,
      // Legacy format for backward compatibility
      drones,
      shipComponents,
      sectionSlots: existingSectionSlots,
      shipId: shipId || null,
      status: 'active'
    };

    this.setState({ singlePlayerShipSlots: slots });
    console.log(`Deck saved to slot ${slotId}:`, deckData);
  }

  /**
   * Delete deck from a ship slot, return cards to inventory
   * @param {number} slotId - Slot ID (1-5, cannot delete 0)
   */
  deleteShipSlotDeck(slotId) {
    if (slotId === 0) {
      throw new Error('Cannot delete Slot 0 (immutable starter deck)');
    }

    const slots = [...this.state.singlePlayerShipSlots];
    const slotIndex = slots.findIndex(s => s.id === slotId);

    if (slotIndex === -1) {
      throw new Error(`Slot ${slotId} not found`);
    }

    const slot = slots[slotIndex];
    if (slot.status !== 'active') {
      throw new Error(`Slot ${slotId} is not active`);
    }

    // Return non-starter-pool cards to inventory
    const newInventory = { ...this.state.singlePlayerInventory };
    (slot.decklist || []).forEach(card => {
      if (!starterPoolCards.includes(card.id)) {
        newInventory[card.id] = (newInventory[card.id] || 0) + card.quantity;
      }
    });

    // Clear instances for this slot
    this.clearSlotInstances(slotId);

    // Reset slot to empty state
    slots[slotIndex] = {
      id: slotId,
      name: `Ship Slot ${slotId}`,
      status: 'empty',
      isImmutable: false,
      decklist: [],
      // New format: empty drone slots
      droneSlots: [
        { slotIndex: 0, slotDamaged: false, assignedDrone: null },
        { slotIndex: 1, slotDamaged: false, assignedDrone: null },
        { slotIndex: 2, slotDamaged: false, assignedDrone: null },
        { slotIndex: 3, slotDamaged: false, assignedDrone: null },
        { slotIndex: 4, slotDamaged: false, assignedDrone: null }
      ],
      // Legacy format for backward compatibility
      drones: [],
      shipComponents: {},
      sectionSlots: {
        l: { componentId: null, damageDealt: 0 },
        m: { componentId: null, damageDealt: 0 },
        r: { componentId: null, damageDealt: 0 }
      }
    };

    // If this was the default slot, reset to 0
    let updatedProfile = this.state.singlePlayerProfile;
    if (updatedProfile.defaultShipSlotId === slotId) {
      updatedProfile = { ...updatedProfile, defaultShipSlotId: 0 };
    }

    this.setState({
      singlePlayerShipSlots: slots,
      singlePlayerInventory: newInventory,
      singlePlayerProfile: updatedProfile
    });

    console.log(`Deck deleted from slot ${slotId}, cards returned to inventory`);
  }

  /**
   * Clear drone and component instances for a slot
   * @param {number} slotId - Slot ID
   */
  clearSlotInstances(slotId) {
    const droneInstances = this.state.singlePlayerDroneInstances.filter(
      i => i.shipSlotId !== slotId
    );
    const componentInstances = this.state.singlePlayerShipComponentInstances.filter(
      i => i.shipSlotId !== slotId
    );

    this.setState({
      singlePlayerDroneInstances: droneInstances,
      singlePlayerShipComponentInstances: componentInstances
    });
  }

  /**
   * Update drone slot order for a ship slot (for Repair Bay reordering)
   * Swaps only assignedDrone values; slotDamaged stays with the slot position
   * @param {number} slotId - Ship slot ID (0-5)
   * @param {Array} newDroneSlots - Updated drone slots array
   */
  updateShipSlotDroneOrder(slotId, newDroneSlots) {
    const slots = [...this.state.singlePlayerShipSlots];
    const slotIndex = slots.findIndex(s => s.id === slotId);

    if (slotIndex === -1) {
      console.warn(`updateShipSlotDroneOrder: Slot ${slotId} not found`);
      return;
    }

    // Update the drone slots
    slots[slotIndex] = {
      ...slots[slotIndex],
      droneSlots: newDroneSlots
    };

    this.setState({ singlePlayerShipSlots: slots });
    debugLog('STATE_SYNC', `Drone order updated for slot ${slotId}`);
  }

  /**
   * Repair a damaged drone slot
   * @param {number} slotId - Ship slot ID (1-5, cannot modify 0)
   * @param {number} position - Drone slot position (0-4)
   * @returns {Object} { success, reason? }
   */
  repairDroneSlot(slotId, position) {
    if (slotId === 0) {
      return { success: false, reason: 'Cannot modify Slot 0 (immutable starter deck)' };
    }

    const slots = [...this.state.singlePlayerShipSlots];
    const slotIndex = slots.findIndex(s => s.id === slotId);

    if (slotIndex === -1) {
      return { success: false, reason: `Slot ${slotId} not found` };
    }

    const slot = slots[slotIndex];
    if (!slot.droneSlots?.[position]) {
      return { success: false, reason: `Drone position ${position} not found` };
    }

    // Support both old (isDamaged) and new (slotDamaged) field names
    const droneSlot = slot.droneSlots[position];
    const isCurrentlyDamaged = droneSlot.slotDamaged ?? droneSlot.isDamaged ?? false;

    if (!isCurrentlyDamaged) {
      return { success: false, reason: 'Drone slot is not damaged' };
    }

    const cost = ECONOMY.DRONE_SLOT_REPAIR_COST || 50;
    const profile = { ...this.state.singlePlayerProfile };

    if (profile.credits < cost) {
      return { success: false, reason: `Insufficient credits. Need ${cost}, have ${profile.credits}` };
    }

    // Deduct credits
    profile.credits -= cost;

    // Repair the slot (set both old and new field names for compatibility)
    slots[slotIndex] = {
      ...slot,
      droneSlots: slot.droneSlots.map((ds, i) =>
        i === position ? { ...ds, slotDamaged: false, isDamaged: false } : ds
      )
    };

    this.setState({
      singlePlayerShipSlots: slots,
      singlePlayerProfile: profile
    });

    console.log(`Repaired drone slot ${position} in ship slot ${slotId} for ${cost} credits`);
    return { success: true };
  }

  /**
   * Repair a damaged section slot (fully repairs all damage)
   * @param {number} slotId - Ship slot ID (1-5, cannot modify 0)
   * @param {string} lane - Lane key ('l', 'm', or 'r')
   * @returns {Object} { success, reason? }
   */
  repairSectionSlot(slotId, lane) {
    if (slotId === 0) {
      return { success: false, reason: 'Cannot modify Slot 0 (immutable starter deck)' };
    }

    const slots = [...this.state.singlePlayerShipSlots];
    const slotIndex = slots.findIndex(s => s.id === slotId);

    if (slotIndex === -1) {
      return { success: false, reason: `Slot ${slotId} not found` };
    }

    const slot = slots[slotIndex];
    if (!slot.sectionSlots?.[lane]) {
      return { success: false, reason: `Lane ${lane} not found` };
    }

    const damageDealt = slot.sectionSlots[lane].damageDealt || 0;
    if (damageDealt <= 0) {
      return { success: false, reason: 'Section is not damaged' };
    }

    const costPerDamage = ECONOMY.SECTION_DAMAGE_REPAIR_COST || 10;
    const cost = damageDealt * costPerDamage;
    const profile = { ...this.state.singlePlayerProfile };

    if (profile.credits < cost) {
      return { success: false, reason: `Insufficient credits. Need ${cost}, have ${profile.credits}` };
    }

    // Deduct credits
    profile.credits -= cost;

    // Repair the section (set damageDealt to 0)
    slots[slotIndex] = {
      ...slot,
      sectionSlots: {
        ...slot.sectionSlots,
        [lane]: { ...slot.sectionSlots[lane], damageDealt: 0 }
      }
    };

    this.setState({
      singlePlayerShipSlots: slots,
      singlePlayerProfile: profile
    });

    console.log(`Repaired section ${lane} in ship slot ${slotId} for ${cost} credits (${damageDealt} damage)`);
    return { success: true };
  }

  /**
   * Repair a section slot partially (incremental repair)
   * @param {number} slotId - Ship slot ID (1-5)
   * @param {string} lane - Lane identifier ('l', 'm', 'r')
   * @param {number} hpToRepair - Amount of HP to repair (default 1)
   * @returns {{ success: boolean, reason?: string, cost?: number, repairedHP?: number, remainingDamage?: number }}
   */
  repairSectionSlotPartial(slotId, lane, hpToRepair = 1) {
    if (slotId === 0) {
      return { success: false, reason: 'Cannot modify Slot 0 (immutable starter deck)' };
    }

    if (hpToRepair < 1) {
      return { success: false, reason: 'Must repair at least 1 HP' };
    }

    const slots = [...this.state.singlePlayerShipSlots];
    const slotIndex = slots.findIndex(s => s.id === slotId);

    if (slotIndex === -1) {
      return { success: false, reason: `Slot ${slotId} not found` };
    }

    const slot = slots[slotIndex];
    if (!slot.sectionSlots?.[lane]) {
      return { success: false, reason: `Lane ${lane} not found` };
    }

    const damageDealt = slot.sectionSlots[lane].damageDealt || 0;
    if (damageDealt <= 0) {
      return { success: false, reason: 'Section is not damaged' };
    }

    // Cap repair amount to actual damage
    const actualRepair = Math.min(hpToRepair, damageDealt);
    const costPerDamage = ECONOMY.SECTION_DAMAGE_REPAIR_COST || 200;
    const cost = actualRepair * costPerDamage;
    const profile = { ...this.state.singlePlayerProfile };

    if (profile.credits < cost) {
      return { success: false, reason: `Insufficient credits. Need ${cost}, have ${profile.credits}` };
    }

    // Deduct credits
    profile.credits -= cost;

    // Reduce damage (partial repair)
    const newDamage = damageDealt - actualRepair;
    slots[slotIndex] = {
      ...slot,
      sectionSlots: {
        ...slot.sectionSlots,
        [lane]: { ...slot.sectionSlots[lane], damageDealt: newDamage }
      }
    };

    this.setState({
      singlePlayerShipSlots: slots,
      singlePlayerProfile: profile
    });

    console.log(`Partial repair: ${actualRepair} HP on section ${lane} in slot ${slotId} for ${cost} credits (${newDamage} damage remaining)`);
    return {
      success: true,
      cost,
      repairedHP: actualRepair,
      remainingDamage: newDamage
    };
  }

  /**
   * Create a drone instance for tracking damage
   * Only for non-starter-pool drones
   * @param {string} droneName - Name of the drone
   * @param {number} slotId - Ship slot ID
   * @returns {string|null} Instance ID or null if starter pool drone
   */
  createDroneInstance(droneName, slotId) {
    // Starter pool drones don't need instances (never damaged)
    if (starterPoolDroneNames.includes(droneName)) {
      return null;
    }

    const instanceId = `DRONE_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const instance = {
      instanceId,
      droneName,
      shipSlotId: slotId,
      isDamaged: false
    };

    const instances = [...this.state.singlePlayerDroneInstances, instance];
    this.setState({ singlePlayerDroneInstances: instances });

    console.log(`Created drone instance: ${instanceId} for ${droneName}`);
    return instanceId;
  }

  /**
   * Update drone instance damage state
   * @param {string} instanceId - Instance ID
   * @param {boolean} isDamaged - New damage state
   */
  updateDroneInstance(instanceId, isDamaged) {
    const instances = [...this.state.singlePlayerDroneInstances];
    const index = instances.findIndex(inst => inst.instanceId === instanceId);

    if (index >= 0) {
      instances[index] = { ...instances[index], isDamaged };
      this.setState({ singlePlayerDroneInstances: instances });
      console.log(`Drone instance ${instanceId} damage updated to ${isDamaged}`);
    } else {
      console.warn(`Drone instance ${instanceId} not found`);
    }
  }

  /**
   * Find drone instance by slot ID and drone name
   * @param {number} slotId - Ship slot ID
   * @param {string} droneName - Drone name
   * @returns {Object|null} Drone instance or null if not found
   */
  findDroneInstance(slotId, droneName) {
    return this.state.singlePlayerDroneInstances.find(
      inst => inst.shipSlotId === slotId && inst.droneName === droneName
    ) || null;
  }

  /**
   * Get damage state for all drones in a specific slot
   * Returns a map of drone name -> isDamaged boolean
   * Slot 0 always returns empty object (starter deck never persists damage)
   * @param {number} slotId - Ship slot ID
   * @returns {Object} Map of drone name to damage state
   */
  getDroneDamageStateForSlot(slotId) {
    // Slot 0 (starter deck) never has persisted damage
    if (slotId === 0) {
      return {};
    }

    const damageState = {};
    this.state.singlePlayerDroneInstances
      .filter(inst => inst.shipSlotId === slotId)
      .forEach(inst => {
        damageState[inst.droneName] = inst.isDamaged || false;
      });

    return damageState;
  }

  /**
   * Create a ship component instance for tracking hull damage
   * Only for non-starter-pool components
   * @param {string} componentId - Component ID
   * @param {number} slotId - Ship slot ID
   * @returns {string|null} Instance ID or null if starter pool component
   */
  createComponentInstance(componentId, slotId) {
    // Starter pool components don't need instances (never damaged)
    if (starterPoolCards.includes(componentId)) {
      return null;
    }

    const component = shipComponentCollection.find(c => c.id === componentId);
    if (!component) {
      throw new Error(`Component ${componentId} not found`);
    }

    const instanceId = `COMP_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const instance = {
      instanceId,
      componentId,
      shipSlotId: slotId,
      currentHull: component.hull,
      maxHull: component.maxHull || component.hull
    };

    const instances = [...this.state.singlePlayerShipComponentInstances, instance];
    this.setState({ singlePlayerShipComponentInstances: instances });

    console.log(`Created component instance: ${instanceId} for ${componentId}`);
    return instanceId;
  }

  /**
   * Start extraction run
   * @param {number} shipSlotId - Ship slot ID to use (0-5)
   * @param {number} mapTier - Map tier (1-3)
   * @param {number} entryGateId - Selected entry gate ID (0-indexed)
   * @param {Object} preGeneratedMap - Optional pre-generated map data from Hangar preview
   * @param {Object} quickDeploy - Optional quick deploy template to use for first combat
   */
  startRun(shipSlotId, mapTier, entryGateId = 0, preGeneratedMap = null, quickDeploy = null) {
    debugLog('EXTRACTION', '=== START RUN ===', {
      shipSlotId,
      mapTier,
      entryGateId,
      hasPreGeneratedMap: !!preGeneratedMap,
      hasQuickDeploy: !!quickDeploy,
      currentAppState: this.state.appState,
      hasExistingRun: tacticalMapStateManager.isRunActive(),
      runAbandoning: this.state.runAbandoning
    });

    const shipSlot = this.state.singlePlayerShipSlots.find(s => s.id === shipSlotId);
    if (!shipSlot) {
      throw new Error('Invalid ship slot ID');
    }

    if (shipSlot.status !== 'active') {
      throw new Error(`Ship slot ${shipSlotId} is not active (status: ${shipSlot.status})`);
    }

    // Get ship card for proper hull/threshold calculation
    // Uses ship's baseHull + section's hullModifier instead of deprecated absolute values
    const shipCard = shipSlot?.shipId
      ? getAllShips().find(s => s.id === shipSlot.shipId)
      : getDefaultShip();

    // Use pre-generated map if provided (from Hangar preview), otherwise generate new
    let mapData;
    if (preGeneratedMap && preGeneratedMap.hexes) {
      mapData = preGeneratedMap;
    } else {
      // Fallback: Generate map using deterministic seed
      const seed = Date.now(); // TODO: Use profile-based seed for reproducibility
      const mapType = 'GENERIC'; // TODO: Support map type selection in Phase 4+
      mapData = generateMapData(seed, mapTier, mapType);
    }

    // Deduct security token if map requires it
    if (mapData.requiresToken) {
      const currentTokens = this.state.singlePlayerProfile?.securityTokens || 0;
      if (currentTokens < 1) {
        console.error('[GameStateManager] Cannot start run - insufficient tokens');
        return;
      }

      // Deduct token
      this.setState({
        singlePlayerProfile: {
          ...this.state.singlePlayerProfile,
          securityTokens: currentTokens - 1
        }
      });
      console.log(`[GameStateManager] Deducted 1 security token. Remaining: ${currentTokens - 1}`);
    }

    // Set player starting position to selected entry gate
    const startingGate = mapData.gates[entryGateId] || mapData.gates[0];

    // Build per-section hull tracking from ship slot components
    // Uses slot-based damage model: damage is stored in sectionSlots, not instances
    const runShipSections = {};
    let totalHull = 0;
    let maxHull = 0;

    // Helper to normalize component type to lowercase camelCase key
    // This ensures consistency with CombatOutcomeProcessor and SinglePlayerCombatInitializer
    // which expect keys like 'bridge', 'powerCell', 'droneControlHub'
    const normalizeTypeToKey = (type) => {
      const typeToKey = {
        'Bridge': 'bridge',
        'Power Cell': 'powerCell',
        'Drone Control Hub': 'droneControlHub'
      };
      return typeToKey[type] || type.charAt(0).toLowerCase() + type.slice(1).replace(/\s+/g, '');
    };

    // Use new slot-based format if available, fall back to legacy
    if (shipSlot?.sectionSlots) {
      // New slot-based format: { l: { componentId, damageDealt }, m: {...}, r: {...} }
      const laneNames = { l: 'left', m: 'middle', r: 'right' };

      Object.entries(shipSlot.sectionSlots).forEach(([lane, sectionSlot]) => {
        if (!sectionSlot?.componentId) return;

        const component = shipComponentCollection.find(c => c.id === sectionSlot.componentId);
        if (component) {
          // Calculate base stats using ship card + section modifiers (correct approach)
          const baseStats = calculateSectionBaseStats(shipCard, component);
          const componentMaxHull = baseStats.maxHull;
          const damageDealt = sectionSlot.damageDealt || 0;

          // For slot 0 (starter deck), ignore any damage
          const hullValue = (shipSlotId === 0)
            ? componentMaxHull
            : Math.max(0, componentMaxHull - damageDealt);

          // Use normalized lowercase key for consistency with CombatOutcomeProcessor
          const sectionKey = normalizeTypeToKey(component.type);
          runShipSections[sectionKey] = {
            id: sectionSlot.componentId,
            name: component.name,
            type: component.type,
            hull: hullValue,
            maxHull: componentMaxHull,
            thresholds: baseStats.thresholds,
            lane: lane
          };
          totalHull += hullValue;
          maxHull += componentMaxHull;
        }
      });
    } else if (shipSlot?.shipComponents) {
      // Legacy format fallback: { componentId: lane }
      Object.entries(shipSlot.shipComponents).forEach(([componentId, lane]) => {
        const component = shipComponentCollection.find(c => c.id === componentId);
        if (component) {
          // Calculate base stats using ship card + section modifiers (correct approach)
          const baseStats = calculateSectionBaseStats(shipCard, component);
          const componentMaxHull = baseStats.maxHull;

          // Use normalized lowercase key for consistency with CombatOutcomeProcessor
          const sectionKey = normalizeTypeToKey(component.type);
          runShipSections[sectionKey] = {
            id: componentId,
            name: component.name,
            type: component.type,
            hull: componentMaxHull,
            maxHull: componentMaxHull,
            thresholds: baseStats.thresholds,
            lane: lane
          };
          totalHull += componentMaxHull;
          maxHull += componentMaxHull;
        }
      });
    }

    // Fallback to default sections if no components defined
    // Uses ship card values instead of hardcoded 10/10
    // Keys use lowercase camelCase for consistency with CombatOutcomeProcessor
    if (Object.keys(runShipSections).length === 0) {
      const defaultThresholds = shipCard?.baseThresholds || { damaged: 4, critical: 0 };
      const defaultHull = shipCard?.baseHull || 8;

      runShipSections.bridge = { type: 'Bridge', hull: defaultHull, maxHull: defaultHull, thresholds: defaultThresholds, lane: 'm' };
      runShipSections.powerCell = { type: 'Power Cell', hull: defaultHull, maxHull: defaultHull, thresholds: defaultThresholds, lane: 'l' };
      runShipSections.droneControlHub = { type: 'Drone Control Hub', hull: defaultHull, maxHull: defaultHull, thresholds: defaultThresholds, lane: 'r' };
      totalHull = defaultHull * 3;
      maxHull = defaultHull * 3;
    }

    const runState = {
      shipSlotId,
      mapTier,
      detection: mapData.baseDetection || 0,  // Use map's starting detection
      playerPosition: startingGate,
      // Track insertion gate separately (gates[0] = entry, gates[1+] = extraction)
      insertionGate: { q: startingGate.q, r: startingGate.r },
      collectedLoot: [],
      creditsEarned: 0,
      mapData,
      // Per-section hull tracking for damage persistence across combats
      shipSections: runShipSections,
      currentHull: totalHull,
      maxHull: maxHull,

      // Run statistics tracking
      runStartTime: Date.now(),
      hexesMoved: 0,
      hexesExplored: [{ q: startingGate.q, r: startingGate.r }], // Start with insertion gate
      poisVisited: [],
      lootedPOIs: [],  // Track POIs that have been looted (prevents re-looting)
      fledPOIs: [],  // Track POIs where player fled/escaped (escape or evade)
      highAlertPOIs: [],  // Track POIs in high alert state after combat victory (increased encounter chance)
      combatsWon: 0,
      combatsLost: 0,
      damageDealtToEnemies: 0,

      // Quick deploy for first combat (consumed after use)
      pendingQuickDeploy: quickDeploy || null,

      // Blockade flags - MUST be initialized false for fresh runs
      // These track post-blockade extraction state and must not persist across runs
      pendingBlockadeExtraction: false,
      blockadeCleared: false,
    };

    debugLog('MODE_TRANSITION', '=== MODE: hangar -> tacticalMap ===', {
      trigger: 'async_event',
      source: 'GameStateManager.startRun',
      detail: 'Deploying screen completed, run initialized',
      shipSlotId,
      mapTier,
      mapName: mapData.name
    });

    // Initialize TacticalMapStateManager with run data
    // This provides clean separation of tactical map state from combat state
    tacticalMapStateManager.startRun({
      shipSlotId,
      mapTier,
      mapData,
      startingGate,
      shipSections: runShipSections
    });
    debugLog('STATE_SYNC', 'TacticalMapStateManager initialized for run');

    this.setState({
      appState: 'tacticalMap',
      // CRITICAL: Clear stale flags from previous runs to prevent race conditions
      // runAbandoning must be false or SinglePlayerCombatInitializer will reject combat init
      runAbandoning: false,
    });

    // CRITICAL: Reset TransitionManager to clear any stale transition state from previous runs
    // This prevents "Transition already in progress" errors when entering combat
    transitionManager.forceReset();

    console.log('Run started via TacticalMapStateManager');
    console.log('Map generated:', mapData.name, `(${mapData.poiCount} PoIs, ${mapData.gateCount} gates)`);
  }

  /**
   * Reset game state to pre-game defaults
   * Used when abandoning mid-combat or exiting games to ensure clean state
   * This is the SINGLE SOURCE OF TRUTH for combat state cleanup
   */
  resetGameState() {
    debugLog('SP_COMBAT', '=== RESET GAME STATE ===');

    // Set context to GameFlowManager since resetGameState legitimately resets
    // game orchestration state (this avoids ownership violations when called
    // from CombatOutcomeProcessor.finalizeLootCollection or other paths)
    this._updateContext = 'GameFlowManager';

    try {
      this.setState({
        // Game flow state
        gameActive: false,
        testMode: false,
        gameSeed: null,
        turnPhase: null,
        gameStage: 'preGame',
        roundNumber: 0,
        turn: 1,
        currentPlayer: 'player1',
        actionsTakenThisTurn: 0,
        firstPlayerOfRound: null,
        firstPasserOfPreviousRound: null,
        firstPlayerOverride: null,

        // Player states
        player1: null,
        player2: null,

        // Pass state
        passInfo: {
          firstPasser: null,
          player1Passed: false,
          player2Passed: false
        },

        // Combat state
        attackInProgress: null,
        lastCombatResult: null,
        winner: null,
        singlePlayerEncounter: null,
        // NOTE: currentRunState now managed by TacticalMapStateManager

        // UI state - ship placement
        placedSections: [],
        opponentPlacedSections: [],
        unplacedSections: [],

        // UI state - game
        gameLog: [],
        commitments: {},
        shieldsToAllocate: 0,
        opponentShieldsToAllocate: 0,

        // Drone selection state
        droneSelectionPool: [],
        droneSelectionTrio: []
      }, 'GAME_STATE_RESET');

      // Reset singletons to ensure clean state for next combat
      // These are idempotent - safe to call multiple times

      // GameFlowManager - reset phase/stage tracking
      if (this.gameFlowManager?.reset) {
        this.gameFlowManager.reset();
        debugLog('SP_COMBAT', '‚úÖ GameFlowManager reset');
      }

      // ActionProcessor - clear queue and locks
      if (this.actionProcessor?.clearQueue) {
        this.actionProcessor.clearQueue();
        // Re-establish GameFlowManager's subscription after clearQueue wipes listeners
        this.gameFlowManager?.resubscribe();
        debugLog('SP_COMBAT', '‚úÖ ActionProcessor queue cleared');
      }

      // AIPhaseProcessor - cleanup subscriptions and timers
      if (aiPhaseProcessor?.cleanup) {
        aiPhaseProcessor.cleanup();
        debugLog('SP_COMBAT', '‚úÖ AIPhaseProcessor cleaned up');
      }
    } finally {
      this._updateContext = null;
    }
  }

  /**
   * End extraction run
   * @param {boolean} success - True if successful extraction, false if MIA
   */
  endRun(success = true) {
    debugLog('SP_COMBAT', '=== END RUN CALLED ===', {
      success,
      currentAppState: this.state.appState,
      currentTurnPhase: this.state.turnPhase,
      currentGameActive: this.state.gameActive,
      currentGameStage: this.state.gameStage,
      hasPlayer1: !!this.state.player1,
      hasPlayer2: !!this.state.player2
    });

    // Read run state from TacticalMapStateManager
    const runState = tacticalMapStateManager.getState();
    if (!runState) {
      console.warn('No active run to end');
      debugLog('SP_COMBAT', 'WARNING: No active run to end');
      return;
    }

    // Generate run summary BEFORE clearing state
    const hexesExploredCount = runState.hexesExplored?.length || 0;
    const totalHexes = runState.mapData?.hexes?.length || 1;
    const runDuration = Date.now() - (runState.runStartTime || Date.now());

    // Get full card data for collected cards
    const cardsCollected = (runState.collectedLoot || [])
      .filter(item => item.type === 'card')
      .map(item => {
        const fullCard = fullCardCollection.find(c => c.id === item.cardId);
        return fullCard ? { ...fullCard, source: item.source } : null;
      })
      .filter(Boolean);

    // Get blueprint data for collected blueprints
    const blueprintsCollected = (runState.collectedLoot || [])
      .filter(item => item.type === 'blueprint')
      .map(item => ({
        blueprintId: item.blueprintId,
        blueprintType: item.blueprintType || 'drone',
        rarity: item.rarity,
        droneData: item.droneData
      }));

    // Calculate credits from salvage items in collectedLoot (not legacy creditsEarned)
    const extractedCredits = calculateExtractedCredits(runState.collectedLoot || []);

    const lastRunSummary = {
      success,
      mapName: runState.mapData?.name || 'Unknown Sector',
      mapTier: runState.mapTier || 1,

      // Movement & Exploration
      hexesMoved: runState.hexesMoved || 0,
      hexesExplored: hexesExploredCount,
      totalHexes,
      mapCompletionPercent: ((hexesExploredCount / totalHexes) * 100).toFixed(1),

      // POIs & Loot
      poisVisited: runState.poisVisited?.length || 0,
      totalPois: runState.mapData?.poiCount || 0,
      cardsCollected, // Full card objects for display
      blueprintsCollected, // Drone blueprints unlocked this run
      creditsEarned: extractedCredits, // Calculated from salvage items
      aiCoresEarned: runState.aiCoresEarned || 0,

      // Combat
      combatsWon: runState.combatsWon || 0,
      combatsLost: runState.combatsLost || 0,
      damageDealtToEnemies: runState.damageDealtToEnemies || 0,

      // Ship Status
      hullDamageTaken: (runState.maxHull || 0) - (runState.currentHull || 0),
      finalHull: runState.currentHull || 0,
      maxHull: runState.maxHull || 0,

      // Time
      runDuration,

      // Detection
      finalDetection: runState.detection || 0,
    };

    console.log('Run summary generated:', lastRunSummary);

    if (success) {
      // Transfer loot to inventory
      runState.collectedLoot.forEach(item => {
        if (item.type === 'card') {
          const cardId = item.cardId;
          this.state.singlePlayerInventory[cardId] =
            (this.state.singlePlayerInventory[cardId] || 0) + 1;
        } else if (item.type === 'blueprint') {
          // Add to unlocked blueprints
          const blueprintId = item.blueprintId;
          if (!this.state.singlePlayerProfile.unlockedBlueprints.includes(blueprintId)) {
            this.state.singlePlayerProfile.unlockedBlueprints.push(blueprintId);
          }
        }
      });

      // Add credits (calculated from salvage items, not legacy creditsEarned)
      this.state.singlePlayerProfile.credits += extractedCredits;

      // Add AI Cores earned from combat
      this.state.singlePlayerProfile.aiCores =
        (this.state.singlePlayerProfile.aiCores || 0) + (runState.aiCoresEarned || 0);

      // Update statistics
      this.state.singlePlayerProfile.stats.runsCompleted++;
      this.state.singlePlayerProfile.stats.totalCreditsEarned += extractedCredits;
      this.state.singlePlayerProfile.stats.totalCombatsWon =
        (this.state.singlePlayerProfile.stats.totalCombatsWon || 0) + (runState.combatsWon || 0);

      // Track highest tier completed
      const currentTier = runState.mapTier || 1;
      if (currentTier > (this.state.singlePlayerProfile.stats.highestTierCompleted || 0)) {
        this.state.singlePlayerProfile.stats.highestTierCompleted = currentTier;
      }

      // Refresh shop pack for next hangar visit (uses updated highestTierCompleted)
      const highestTier = this.state.singlePlayerProfile.stats.highestTierCompleted || 0;
      this.state.singlePlayerProfile.shopPack = generateRandomShopPack(highestTier, Date.now());
      console.log('Shop pack refreshed:', this.state.singlePlayerProfile.shopPack);

      console.log('Run ended successfully - loot transferred');

      // Persist ship section hull damage using slot-based format
      // Damage is stored in sectionSlots[lane].damageDealt, not in instance arrays
      if (runState.shipSlotId !== 0 && runState.shipSections) {
        const slots = [...this.state.singlePlayerShipSlots];
        const slotIndex = slots.findIndex(s => s.id === runState.shipSlotId);

        if (slotIndex >= 0 && slots[slotIndex].sectionSlots) {
          const shipSlot = { ...slots[slotIndex] };
          const newSectionSlots = { ...shipSlot.sectionSlots };

          // Map section names to lanes for persistence
          Object.entries(runState.shipSections).forEach(([sectionName, sectionData]) => {
            const lane = sectionData.lane; // 'l', 'm', or 'r'
            if (lane && newSectionSlots[lane]) {
              // Calculate damage dealt = maxHull - currentHull
              const damageDealt = (sectionData.maxHull || 10) - (sectionData.hull || 0);
              newSectionSlots[lane] = {
                ...newSectionSlots[lane],
                damageDealt: Math.max(0, damageDealt)
              };
            }
          });

          shipSlot.sectionSlots = newSectionSlots;
          slots[slotIndex] = shipSlot;
          this.state.singlePlayerShipSlots = slots;
          console.log('Ship section hull damage persisted to sectionSlots');
        }
      }
    } else {
      // MIA: Wipe loot, mark slot
      const shipSlot = this.state.singlePlayerShipSlots.find(
        s => s.id === runState.shipSlotId
      );
      // Slot 0 (Starter Deck) never goes MIA - player just loses loot
      if (shipSlot && shipSlot.id !== 0) {
        shipSlot.status = 'mia';
      }

      // Update statistics
      this.state.singlePlayerProfile.stats.runsLost++;

      console.log('Run ended - MIA protocol triggered');
    }

    // Calculate total combat reputation from run
    const combatReputationArray = runState.combatReputationEarned || [];
    const totalCombatRep = combatReputationArray.reduce((sum, entry) => sum + entry.repEarned, 0);

    debugLog('REPUTATION', 'Combat reputation summary:', {
      combatCount: combatReputationArray.length,
      totalCombatRep,
      breakdown: combatReputationArray
    });

    // Award reputation based on loadout value + combat reputation
    const shipSlot = this.state.singlePlayerShipSlots.find(
      s => s.id === runState.shipSlotId
    );
    const reputationResult = ReputationService.awardReputation(
      shipSlot,
      runState.mapTier || 1,
      success,
      totalCombatRep  // NEW: Pass combat reputation
    );

    // Add reputation info to run summary
    lastRunSummary.reputation = {
      repGained: reputationResult.repGained || 0,
      loadoutRepGained: reputationResult.loadoutRepGained || 0,  // NEW: Breakdown
      combatRepGained: reputationResult.combatRepGained || 0,     // NEW: Breakdown
      previousRep: reputationResult.previousRep || 0,
      newRep: reputationResult.newRep || 0,
      previousLevel: reputationResult.previousLevel || 1,
      newLevel: reputationResult.newLevel || 1,
      leveledUp: reputationResult.leveledUp || false,
      levelsGained: reputationResult.levelsGained || 0,
      newRewards: reputationResult.newRewards || [],
      loadoutValue: reputationResult.loadout?.totalValue || 0,
      isStarterDeck: reputationResult.loadout?.isStarterDeck || false,
      wasCapped: reputationResult.wasCapped || false,
      tierCap: reputationResult.tierCap || 0,
    };

    console.log('Reputation awarded:', lastRunSummary.reputation);

    // End the run in TacticalMapStateManager
    tacticalMapStateManager.endRun();
    debugLog('STATE_SYNC', 'TacticalMapStateManager run ended');

    // Set summary for display at hangar
    // Include singlePlayerProfile so React subscribers see the stats change
    // NOTE: Run state is cleared via tacticalMapStateManager.endRun() above
    this.setState({
      lastRunSummary,
      singlePlayerProfile: { ...this.state.singlePlayerProfile }
    });

    debugLog('SP_COMBAT', '=== END RUN COMPLETE ===', {
      clearedRunState: !tacticalMapStateManager.isRunActive(),
      // Note: game state (player1, player2, gameActive) is NOT cleared by endRun
      gameActiveStillSet: this.state.gameActive,
      turnPhaseStillSet: this.state.turnPhase,
      hasPlayer1StillSet: !!this.state.player1,
      hasPlayer2StillSet: !!this.state.player2
    });
  }
}

// Create singleton instance
const gameStateManager = new GameStateManager();

// Preserve singleton across Hot Module Replacement (HMR) in development
// This prevents state loss during development when files are edited
if (import.meta.hot) {
  import.meta.hot.accept();
  // Store the current instance in HMR data to preserve across reloads
  if (import.meta.hot.data?.gameStateManager) {
    // Restore the previous instance's state
    gameStateManager.state = import.meta.hot.data.gameStateManager.state;
    gameStateManager.listeners = import.meta.hot.data.gameStateManager.listeners;
    debugLog('STATE_SYNC', 'üîÑ HMR: Preserved GameStateManager state across hot reload');
  }
  import.meta.hot.dispose((data) => {
    // Store instance before disposing
    data.gameStateManager = gameStateManager;
  });
}

export default gameStateManager;