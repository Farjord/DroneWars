import{G as U,f as j}from"./index-C3A59Ji0.js";const O=(d,i,A,B,p,S)=>{const b=i.dronesOnBoard[d]||[],k=A.dronesOnBoard[d]||[],I=parseInt(d.slice(-1))-1,g=(s,t,o,n)=>s.reduce((a,c)=>{const r=S.getEffectiveStats(c,d),f=(r.attack||0)+(r.potentialShipDamage||0);return a+f+(c.hull||0)+(c.currentShields||0)},0),T=g(b),E=g(k),P=T-E,$=(s,t,o,n)=>s.length===0?0:Math.max(...s.map(a=>S.getEffectiveStats(a,d).speed)),w=$(b),v=$(k),H=(w-v)*5;let y=0;const G=B.player2[I];if(G){const s=p(i.shipSections[G]);s==="damaged"&&(y-=20),s==="critical"&&(y-=40)}const e=B.player1[I];if(e){const s=p(A.shipSections[e]);s==="damaged"&&(y+=15),s==="critical"&&(y+=30)}return P+H+y},Y=({player1:d,player2:i,turn:A,placedSections:B,opponentPlacedSections:p,getShipStatus:S,gameStateManager:b,addLogEntry:k})=>{const I=U.getInstance(b),g=I.getEffectiveShipStats(i,p).totals,T=Object.values(i.dronesOnBoard).flat().length,E=A===1?i.initialDeploymentBudget+i.energy:i.deploymentBudget+i.energy,P=[...i.hand].sort((o,n)=>n.cost-o.cost),$=P[0]?.cost||0;console.log("[AI ENERGY DEBUG] Deployment energy management:",{currentEnergy:i.energy,reservedEnergy:$,cardsInHand:i.hand.map(o=>({name:o.name,cost:o.cost})),mostExpensiveCard:P[0]?.name||"None",turn:A,deploymentBudget:A===1?i.initialDeploymentBudget:i.deploymentBudget});const w=i.activeDronePool,v=[],H=["lane1","lane2","lane3"],y={player1:B,player2:p},G={lane1:O("lane1",i,d,y,S,I),lane2:O("lane2",i,d,y,S,I),lane3:O("lane3",i,d,y,S,I)};for(const o of w){const n=o.class;let a=!0,c="";if(E<n)a=!1,c="Insufficient total resources";else if((i.deployedDroneCounts[o.name]||0)>=o.limit)a=!1,c="Deployment limit reached";else if(T>=g.cpuLimit)a=!1,c="CPU limit reached";else{const r=A===1?i.initialDeploymentBudget:i.deploymentBudget,f=Math.min(r,n),l=n-f,u=i.energy-l;u<$?(a=!1,c=`Reserves energy for cards (needs ${$})`,console.log(`[AI ENERGY DEBUG] ${o.name} rejected: energy after deployment (${u}) < reserved (${$})`)):console.log(`[AI ENERGY DEBUG] ${o.name} affordable: energy after deployment (${u}) >= reserved (${$})`)}if(!a){v.push({drone:o,laneId:"N/A",score:-999,instigator:o.name,targetName:"N/A",logic:[c]});continue}for(const r of H){const f=JSON.parse(JSON.stringify(i)),l=j.find(x=>x.name===o.name);f.dronesOnBoard[r].push({...l,id:"temp"});const u=O(r,f,d,y,S,I),L=u-G[r];let m=0;const h=G[r],N=new Set(l.abilities.filter(x=>x.effect.keyword).map(x=>x.effect.keyword));h<-15?(o.speed>=4&&(m+=15),(N.has("ALWAYS_INTERCEPTS")||N.has("GUARDIAN"))&&(m+=20)):h>15?(o.attack>=4&&(m+=15),l.abilities.some(x=>x.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(m+=20)):o.class<=1&&(m+=10);let M=0;h<0&&u>=0&&(M=Math.floor(Math.random()*21)+10);let _=0;u>20&&h<=20&&(_=Math.floor(Math.random()*21)+10);const C=[`LaneScore: ${h.toFixed(0)}`,`Projected: ${u.toFixed(0)}`,`Impact: ${L.toFixed(0)}`,`Bonus: ${m.toFixed(0)}`,`Stabilize: ${M.toFixed(0)}`,`Dominance: ${_.toFixed(0)}`];let F=0;const V=parseInt(r.slice(-1))-1,D=B[V];if(D){const x=S(d.shipSections[D]);(x==="damaged"||x==="critical")&&h>5&&(F=-150,C.push(`Overkill Penalty: ${F}`))}const R=L+m+M+_+F;v.push({drone:o,laneId:r,score:R,instigator:o.name,targetName:r,logic:C})}}const e=v.length>0?Math.max(...v.map(o=>o.score)):-1;if(e<5)return k({player:i.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during deployment phase (no high-impact plays)."},"aiDeploymentPass",v),{type:"pass"};const s=v.filter(o=>o.score===e),t=s[Math.floor(Math.random()*s.length)];return t.isChosen=!0,{type:"deploy",payload:{droneToDeploy:t.drone,targetLane:t.laneId,logContext:v}}},W=({player1:d,player2:i,placedSections:A,opponentPlacedSections:B,getShipStatus:p,getLaneOfDrone:S,gameStateManager:b,getValidTargets:k,addLogEntry:I})=>{const g=U.getInstance(b),T={player1:A,player2:B},E=[],P=new Set,$=Object.entries(i.dronesOnBoard).flatMap(([e,s])=>s.filter(t=>!t.isExhausted).map(t=>({...t,lane:e}))),w=i.hand.filter(e=>i.energy>=e.cost);for(const e of w)if(e.targeting){let s=k("player2",null,e,d,i);e.effect.type==="HEAL_SHIELDS"&&(s=s.filter(t=>t.currentShields<t.currentMaxShields)),e.effect.type==="HEAL_HULL"&&e.targeting.type==="SHIP_SECTION"&&(s=s.filter(t=>t.hull<t.maxHull)),(e.effect.type==="DAMAGE"||e.effect.type==="DESTROY")&&(s=s.filter(t=>t.owner==="player1"));for(const t of s){const o=`card-${e.id}-${t.id}-${t.owner}`;P.has(o)||(E.push({type:"play_card",card:e,target:t,score:0}),P.add(o))}}else{const s=`card-${e.id}`;P.has(s)||(E.push({type:"play_card",card:e,target:null,score:0}),P.add(s))}for(const e of $){const s=d.dronesOnBoard[e.lane];for(const n of s)E.push({type:"attack",attacker:e,target:{...n,owner:"player1"},targetType:"drone",score:0});const t=parseInt(e.lane.slice(-1))-1,o=A[t];if(o&&d.shipSections[o].hull>0&&!d.dronesOnBoard[e.lane].some(c=>g.getEffectiveStats(c,e.lane).keywords.has("GUARDIAN"))){const c={id:o,name:o,...d.shipSections[o],owner:"player1"};E.push({type:"attack",attacker:e,target:c,targetType:"section",score:0})}}for(const e of $){const s=parseInt(e.lane.slice(-1));[s-1,s+1].forEach(t=>{if(t>=1&&t<=3){const o=`lane${t}`;E.push({type:"move",drone:e,fromLane:e.lane,toLane:o,score:0})}})}E.forEach(e=>{e.instigator=e.card?.name||e.attacker?.name,e.targetName=e.target?.name||e.target?.id||"N/A",e.logic=[];let s=0;switch(e.type){case"play_card":{const{card:t,target:o}=e;if(t.effect.type==="DESTROY"){if(t.effect.scope==="SINGLE"&&o){const n=(o.hull||0)+(o.currentShields||0);s=n*8-t.cost*4,e.logic.push(`(Target Value: ${n} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="FILTERED"&&o&&o.id.startsWith("lane")){const{stat:n,comparison:a,value:c}=t.effect.filter,r=d.dronesOnBoard[o.id]||[];let f=0;r.forEach(l=>{let u=!1;a==="GTE"&&l[n]>=c&&(u=!0),a==="LTE"&&l[n]<=c&&(u=!0),u&&(f+=(l.hull||0)+(l.currentShields||0)+l.class*5)}),s=f*8-t.cost*4,e.logic.push(`(Filtered Value: ${f} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="LANE"&&o&&o.id.startsWith("lane")){const n=o.id,a=d.dronesOnBoard[n]||[],c=i.dronesOnBoard[n]||[],r=m=>m.reduce((h,N)=>{const M=(N.hull||0)+(N.currentShields||0)+N.class*5;return h+(N.isExhausted?M:M*1.5)},0),f=r(a),l=r(c),u=4,L=t.cost*4;s=(f-l)*u-L,e.logic.push(`((Enemy Val: ${f.toFixed(0)} - Friendly Val: ${l.toFixed(0)}) * ${u}) - Cost: ${L}`)}}else if(t.effect.type==="DAMAGE"&&o)if(t.effect.scope==="FILTERED"&&o.id.startsWith("lane")&&t.effect.filter){const{stat:n,comparison:a,value:c}=t.effect.filter,r=d.dronesOnBoard[o.id]||[];let f=0,l=0;const u=o.id;r.forEach(L=>{const m=g.getEffectiveStats(L,u);let h=!1;a==="GTE"&&m[n]>=c&&(h=!0),a==="LTE"&&m[n]<=c&&(h=!0),h&&(l++,f+=t.effect.value)}),s=f*10+(l>1?l*15:0)-t.cost*4,e.logic.push(`(Filtered Damage: ${f} * 10) + (Multi-Hit Bonus: ${l>1?l*15:0}) - (Card Cost: ${t.cost} * 4)`)}else{let n=t.effect.value,a=[];if(t.effect.damageType==="PIERCING"){const l=o.currentShields||0;a.push(`Piercing bypasses ${l} shields`)}const c=t.effect.value*8;a.push(`Base Dmg: ${c}`);let r=c;if(n>=o.hull){const l=o.class*15+50;r+=l,a.push(`Lethal Bonus: +${l}`)}const f=t.cost*4;r-=f,a.push(`Cost: -${f}`),s=r,e.logic.push(...a.map(l=>`(${l})`))}else if(t.effect.type==="READY_DRONE")s=o.class*12;else if(t.effect.type==="GAIN_ENERGY"){const n=i.energy-t.cost+t.effect.value;e.logic.push(`Projected Energy: ${n}`);const a=i.hand.filter(c=>c.instanceId!==t.instanceId&&i.energy<c.cost&&n>=c.cost);if(a.length>0){const c=a.sort((r,f)=>f.cost-r.cost)[0];s=60+c.cost*5,e.logic.push(`Enables Play of '${c.name}' (Cost ${c.cost}): +${s}`)}else s=1,e.logic.push("No new cards enabled. Low priority.")}else if(t.effect.type==="DRAW"){const n=i.energy-t.cost;n>0?(s=10+n*2,e.logic.push(`(Base: 10) + (Energy Left: ${n} * 2)`)):(s=1,e.logic.push("Low Priority: 1"))}else if(t.effect.type==="SEARCH_AND_DRAW"){const n=i.energy-t.cost,a=t.effect.drawCount*12,c=t.effect.searchCount*2;n>=0?(s=a+c+n*2,e.logic.push(`(Draw Value: ${a}) + (Search Bonus: ${c}) + (Energy Left: ${n} * 2)`)):(s=2,e.logic.push("Low Priority: 2"))}else if(t.effect.type==="HEAL_SHIELDS"){const n=Math.min(t.effect.value,o.currentMaxShields-o.currentShields);s=n*5,e.logic.push(`(Shields Healed: ${n} * 5)`)}else if(t.effect.type==="HEAL_HULL"&&t.targeting.type==="SHIP_SECTION")s=80,e.logic.push("High Priority Section Heal: 80");else if(t.effect.type==="REPEATING_EFFECT"){let n=1;if(t.condition==="OWN_DAMAGED_SECTIONS")for(const a in i.shipSections){const c=i.shipSections[a],r=p(c);(r==="damaged"||r==="critical")&&n++}s=n*25-t.cost*4,e.logic.push(`(Repeats: ${n} * 25) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.type==="MODIFY_STAT"){const{mod:n}=t.effect,{target:a}=e;if(t.targeting?.type==="LANE"){const c=a.id,f=(i.dronesOnBoard[c]||[]).filter(l=>!l.isExhausted);if(f.length===0)s=0,e.logic.push("No Active Drones in Lane");else{const l=O(c,i,d,T,p,g),u=JSON.parse(JSON.stringify(i));u.dronesOnBoard[c].forEach(h=>{h.isExhausted||(h.statMods||(h.statMods=[]),h.statMods.push(n))});const m=O(c,u,d,T,p,g)-l;s=m*1.5+f.length*10,e.logic.push(`Lane Impact: ${m.toFixed(0)}`),e.logic.push(`Multi-Buff Bonus: ${f.length*10}`)}}else if(n.stat==="attack"&&n.value>0)a.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=a.class*10+n.value*8,e.logic.push(`Target Class: ${a.class*10}`),e.logic.push(`Attack Value: ${n.value*8}`));else if(n.stat==="attack"&&n.value<0)if(a.isExhausted)s=-1,e.logic.push("Invalid Target (Already Exhausted)");else{const c=g.getEffectiveStats(a,S(a.id,d));s=c.attack*8-n.value*-5,e.logic.push(`Threat Reduction: ${c.attack*8}`)}else if(n.stat==="speed"&&n.value>0)if(a.isExhausted)s=-1,e.logic.push("Invalid (Exhausted)");else{const c=S(a.id,i),r=d.dronesOnBoard[c]||[],f=r.length>0?Math.max(...r.map(u=>g.getEffectiveStats(u,c).speed)):-1,l=g.getEffectiveStats(a,c);l.speed<=f&&l.speed+n.value>f?(s=60,e.logic.push("Interceptor Overcome Bonus: 60")):(s=20,e.logic.push("Utility Speed Bonus: 20"))}else a.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=10,e.logic.push("Generic stat modification"));s>0&&(n.type==="permanent"&&(s*=1.5,e.logic.push("Permanent Mod x1.5")),t.effect.goAgain&&(s+=40,e.logic.push("Go Again Bonus: +40")),s-=t.cost*4,e.logic.push(`Cost: -${t.cost*4}`))}e.score=s;break}case"attack":{const{attacker:t,target:o,targetType:n}=e,a=g.getEffectiveStats(t,t.lane),c=Math.max(0,a.attack);if(n==="drone"){const r=g.getEffectiveStats(o,t.lane);if(s=r.class*10,e.logic.push(`(Target Class: ${r.class} * 10)`),a.class<r.class&&(s+=20,e.logic.push("Favorable Trade Bonus: 20")),o.isExhausted||(s+=10,e.logic.push("Ready Target Bonus: 10")),j.find(u=>u.name===t.name)?.abilities.some(u=>u.type==="PASSIVE"&&u.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(s-=40,e.logic.push("Anti-Ship Penalty: -40")),t.damageType==="PIERCING"){const u=r.currentShields*8;s+=u,e.logic.push(`Piercing Bonus: ${u}`)}}else if(n==="section"){s=c*8,e.logic.push(`(Effective Attack: ${c} * 8)`);const r=p(o);if(r==="damaged"&&(s+=15,e.logic.push("Damaged Section Bonus: 15")),r==="critical"&&(s+=30,e.logic.push("Critical Section Bonus: 30")),o.allocatedShields===0?(s+=40,e.logic.push("No Shields Bonus: 40")):c>=o.allocatedShields&&(s+=35,e.logic.push("Shield Break Bonus: 35")),c>=3&&(s+=10,e.logic.push("High Attack Bonus: 10")),t.damageType==="PIERCING"){const f=o.allocatedShields*10;s+=f,e.logic.push(`Piercing Bonus: ${f}`)}}e.score=s;break}case"move":{const{drone:t,fromLane:o,toLane:n}=e;e.instigator=t.name,e.targetName=n;const a=O(o,i,d,T,p,g),c=O(n,i,d,T,p,g),r=JSON.parse(JSON.stringify(i)),f=r.dronesOnBoard[o].find(C=>C.id===t.id);f&&(r.dronesOnBoard[o]=r.dronesOnBoard[o].filter(C=>C.id!==t.id),r.dronesOnBoard[n].push(f));const l=O(o,r,d,T,p,g),L=O(n,r,d,T,p,g)-c,m=l-a,h=10;s=L+m-h,e.logic.push(`ToLane Impact: ${L.toFixed(0)}`),e.logic.push(`FromLane Impact: ${m.toFixed(0)}`),e.logic.push(`Move Cost: -${h}`);const N=parseInt(n.slice(-1))-1,M=B[N];if(M){const C=p(i.shipSections[M]);(C==="damaged"||C==="critical")&&c<0&&(s+=25,e.logic.push("Defensive Bonus: +25"))}const _=A[N];if(_){const F=j.find(D=>D.name===t.name)?.abilities.find(D=>D.type==="TRIGGERED"&&D.trigger==="ON_MOVE");if(F){let D=0;F.effects?.forEach(R=>{R.type==="PERMANENT_STAT_MOD"&&(R.mod.stat==="attack"&&(D+=R.mod.value*15),R.mod.stat==="speed"&&(D+=R.mod.value*10))}),s+=D,e.logic.push(`OnMove Bonus: +${D}`)}const V=p(d.shipSections[_]);c>0&&(V==="damaged"?(s+=20,e.logic.push("Offensive Bonus (Damaged Section): +20")):V==="critical"&&(s-=150,e.logic.push("Overkill Penalty (Critical Section): -150")))}e.score=s;break}}});const v=E.length>0?Math.max(...E.map(e=>e.score)):0;if(v<=0)return I({player:i.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during action phase."},"aiActionPass",E),{type:"pass"};const y=E.filter(e=>e.score>=v-20).filter(e=>e.score>0),G=y[Math.floor(Math.random()*y.length)];return G.isChosen=!0,{type:"action",payload:G,logContext:E}},J=(d,i)=>{if(!d||d.length===0)return{interceptor:null};const B=[...d].sort((b,k)=>{const I=b.class??1/0,g=k.class??1/0;return I-g})[0],p=i.class??1/0,S=B.class??1/0;return p===void 0||S<p?{interceptor:B}:{interceptor:null}},K={handleOpponentTurn:Y,handleOpponentAction:W,makeInterceptionDecision:J};export{K as aiBrain};
