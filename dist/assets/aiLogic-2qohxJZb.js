import{G as W,f as j,d as J}from"./index-a2i0oWti.js";const U=f=>f.abilities?.some(a=>a.effect?.type==="GRANT_KEYWORD"&&a.effect?.keyword==="JAMMER"),Y=(f,a)=>(f.dronesOnBoard[a]||[]).some(U),K=(f,a,A)=>f.dronesOnBoard[A]?f.dronesOnBoard[A].filter(v=>v.name===a).length:0,P=(f,a,A,v,m,I)=>{const b=a.dronesOnBoard[f]||[],k=A.dronesOnBoard[f]||[],D=parseInt(f.slice(-1))-1,g=(e,s,t,r)=>e.reduce((o,c)=>{const n=I.getEffectiveStats(c,f),i=(n.attack||0)+(n.potentialShipDamage||0);return o+i+(c.hull||0)+(c.currentShields||0)},0),N=g(b),y=g(k),x=N-y,O=(e,s,t,r)=>e.length===0?0:Math.max(...e.map(o=>I.getEffectiveStats(o,f).speed)),F=O(b),B=O(k),_=(F-B)*5;let L=0;const R=v.player2[D];if(R){const e=m(a.shipSections[R]);e==="damaged"&&(L-=20),e==="critical"&&(L-=40)}const G=v.player1[D];if(G){const e=m(A.shipSections[G]);e==="damaged"&&(L+=15),e==="critical"&&(L+=30)}return x+_+L},q=({player1:f,player2:a,turn:A,placedSections:v,opponentPlacedSections:m,getShipStatus:I,gameStateManager:b,addLogEntry:k})=>{const D=W.getInstance(b),g=D.getEffectiveShipStats(a,m).totals,N=Object.values(a.dronesOnBoard).flat().length,y=A===1?a.initialDeploymentBudget+a.energy:a.deploymentBudget+a.energy,x=[...a.hand].sort((t,r)=>r.cost-t.cost),O=x[0]?.cost||0;J("AI_DECISIONS","[AI ENERGY DEBUG] Deployment energy management:",{currentEnergy:a.energy,cardsInHand:a.hand.map(t=>({name:t.name,cost:t.cost})),mostExpensiveCard:x[0]?.name||"None",deploymentBudget:A===1?a.initialDeploymentBudget:a.deploymentBudget});const F=a.activeDronePool,B=[],_=["lane1","lane2","lane3"],L={player1:v,player2:m},R={lane1:P("lane1",a,f,L,I,D),lane2:P("lane2",a,f,L,I,D),lane3:P("lane3",a,f,L,I,D)};for(const t of F){const r=t.class;let o=!0,c="";if(y<r)o=!1,c="Insufficient total resources";else if((a.deployedDroneCounts[t.name]||0)>=t.limit)o=!1,c="Deployment limit reached";else if(N>=g.cpuLimit)o=!1,c="CPU limit reached";else{const n=A===1?a.initialDeploymentBudget:a.deploymentBudget,i=Math.min(n,r),d=r-i,l=a.energy-d;l<O?(o=!1,c=`Reserves energy for cards (needs ${O})`,J("AI_DECISIONS",`[AI ENERGY DEBUG] ${t.name} rejected: energy after deployment (${l}) < reserved (${O})`)):J("AI_DECISIONS",`[AI ENERGY DEBUG] ${t.name} affordable: energy after deployment (${l}) >= reserved (${O})`)}if(!o){B.push({drone:t,laneId:"N/A",score:-999,instigator:t.name,targetName:"N/A",logic:[c]});continue}for(const n of _){const i=j.find(S=>S.name===t.name);if(i.maxPerLane){const S=K(a,t.name,n);if(S>=i.maxPerLane){B.push({drone:t,laneId:n,score:-999,instigator:t.name,targetName:n,logic:[`Max per lane reached (${S}/${i.maxPerLane})`]});continue}}const d=JSON.parse(JSON.stringify(a));d.dronesOnBoard[n].push({...i,id:"temp"});const l=P(n,d,f,L,I,D),u=l-R[n];let h=0;const p=R[n],E=new Set(i.abilities.filter(S=>S.effect.keyword).map(S=>S.effect.keyword));p<-15?(t.speed>=4&&(h+=15),(E.has("ALWAYS_INTERCEPTS")||E.has("GUARDIAN"))&&(h+=20)):p>15?(t.attack>=4&&(h+=15),i.abilities.some(S=>S.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(h+=20)):t.class<=1&&(h+=10);let $=0;p<0&&l>=0&&($=Math.floor(Math.random()*21)+10);let M=0;l>20&&p<=20&&(M=Math.floor(Math.random()*21)+10);const w=[`LaneScore: ${p.toFixed(0)}`,`Projected: ${l.toFixed(0)}`,`Impact: ${u.toFixed(0)}`,`Bonus: ${h.toFixed(0)}`,`Stabilize: ${$.toFixed(0)}`,`Dominance: ${M.toFixed(0)}`];let T=0;const H=parseInt(n.slice(-1))-1,V=v[H];if(V){const S=I(f.shipSections[V]);(S==="damaged"||S==="critical")&&p>5&&(T=-150,w.push(`Overkill Penalty: ${T}`))}const C=u+h+$+M+T;B.push({drone:t,laneId:n,score:C,instigator:t.name,targetName:n,logic:w})}}const G=B.length>0?Math.max(...B.map(t=>t.score)):-1;if(G<5)return k({player:a.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during deployment phase (no high-impact plays)."},"aiDeploymentPass",B),{type:"pass"};const e=B.filter(t=>t.score===G),s=e[Math.floor(Math.random()*e.length)];return s.isChosen=!0,{type:"deploy",payload:{droneToDeploy:s.drone,targetLane:s.laneId,logContext:B}}},z=({player1:f,player2:a,placedSections:A,opponentPlacedSections:v,getShipStatus:m,getLaneOfDrone:I,gameStateManager:b,getValidTargets:k,addLogEntry:D})=>{const g=W.getInstance(b),N={player1:A,player2:v},y=[],x=new Set,O=Object.entries(a.dronesOnBoard).flatMap(([e,s])=>s.filter(t=>!t.isExhausted).map(t=>({...t,lane:e}))),F=a.hand.filter(e=>a.energy>=e.cost);for(const e of F)if(e.targeting){let s=k("player2",null,e,f,a);e.effect.type==="HEAL_SHIELDS"&&(s=s.filter(t=>t.currentShields<t.currentMaxShields)),e.effect.type==="HEAL_HULL"&&e.targeting.type==="SHIP_SECTION"&&(s=s.filter(t=>t.hull<t.maxHull)),(e.effect.type==="DAMAGE"||e.effect.type==="DESTROY")&&(s=s.filter(t=>t.owner==="player1"));for(const t of s){const r=`card-${e.id}-${t.id}-${t.owner}`;x.has(r)||(y.push({type:"play_card",card:e,target:t,score:0}),x.add(r))}}else{const s=`card-${e.id}`;x.has(s)||(y.push({type:"play_card",card:e,target:null,score:0}),x.add(s))}for(const e of O){const s=f.dronesOnBoard[e.lane];for(const o of s)y.push({type:"attack",attacker:e,target:{...o,owner:"player1"},targetType:"drone",score:0});const t=parseInt(e.lane.slice(-1))-1,r=A[t];if(r&&f.shipSections[r].hull>0&&!f.dronesOnBoard[e.lane].some(n=>g.getEffectiveStats(n,e.lane).keywords.has("GUARDIAN"))){const n={...f.shipSections[r],id:r,name:r,owner:"player1"};y.push({type:"attack",attacker:e,target:n,targetType:"section",score:0})}}for(const e of O){const s=parseInt(e.lane.slice(-1));[s-1,s+1].forEach(t=>{if(t>=1&&t<=3){const r=`lane${t}`,o=j.find(c=>c.name===e.name);if(o&&o.maxPerLane&&K(a,e.name,r)>=o.maxPerLane)return;y.push({type:"move",drone:e,fromLane:e.lane,toLane:r,score:0})}})}y.forEach(e=>{e.instigator=e.card?.name||e.attacker?.name,e.targetName=e.target?.name||e.target?.id||"N/A",e.logic=[];let s=0;switch(e.type){case"play_card":{const{card:t,target:r}=e;if(t.effect.type==="DESTROY"){if(t.effect.scope==="SINGLE"&&r){const o=(r.hull||0)+(r.currentShields||0);s=o*8-t.cost*4,e.logic.push(`(Target Value: ${o} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="FILTERED"&&r&&r.id.startsWith("lane")){const{stat:o,comparison:c,value:n}=t.effect.filter,i=f.dronesOnBoard[r.id]||[];let d=0;i.forEach(l=>{let u=!1;c==="GTE"&&l[o]>=n&&(u=!0),c==="LTE"&&l[o]<=n&&(u=!0),u&&(d+=(l.hull||0)+(l.currentShields||0)+l.class*5)}),s=d*8-t.cost*4,e.logic.push(`(Filtered Value: ${d} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="LANE"&&r&&r.id.startsWith("lane")){const o=r.id,c=f.dronesOnBoard[o]||[],n=a.dronesOnBoard[o]||[],i=p=>p.reduce((E,$)=>{const M=($.hull||0)+($.currentShields||0)+$.class*5;return E+($.isExhausted?M:M*1.5)},0),d=i(c),l=i(n),u=4,h=t.cost*4;s=(d-l)*u-h,e.logic.push(`((Enemy Val: ${d.toFixed(0)} - Friendly Val: ${l.toFixed(0)}) * ${u}) - Cost: ${h}`)}}else if(t.effect.type==="DAMAGE"&&r)if(t.effect.scope==="FILTERED"&&r.id.startsWith("lane")&&t.effect.filter){const{stat:o,comparison:c,value:n}=t.effect.filter,i=f.dronesOnBoard[r.id]||[];let d=0,l=0;const u=r.id;i.forEach(h=>{const p=g.getEffectiveStats(h,u);let E=!1;c==="GTE"&&p[o]>=n&&(E=!0),c==="LTE"&&p[o]<=n&&(E=!0),E&&(l++,d+=t.effect.value)}),s=d*10+(l>1?l*15:0)-t.cost*4,e.logic.push(`(Filtered Damage: ${d} * 10) + (Multi-Hit Bonus: ${l>1?l*15:0}) - (Card Cost: ${t.cost} * 4)`)}else{let o=t.effect.value,c=[];if(t.effect.damageType==="PIERCING"){const l=r.currentShields||0;c.push(`Piercing bypasses ${l} shields`)}const n=t.effect.value*8;c.push(`Base Dmg: ${n}`);let i=n;if(o>=r.hull){const l=r.class*15+50;i+=l,c.push(`Lethal Bonus: +${l}`)}const d=t.cost*4;i-=d,c.push(`Cost: -${d}`),s=i,e.logic.push(...c.map(l=>`(${l})`))}else if(t.effect.type==="READY_DRONE")s=r.class*12;else if(t.effect.type==="GAIN_ENERGY"){const o=a.energy-t.cost+t.effect.value;e.logic.push(`Projected Energy: ${o}`);const c=a.hand.filter(n=>n.instanceId!==t.instanceId&&a.energy<n.cost&&o>=n.cost);if(c.length>0){const n=c.sort((i,d)=>d.cost-i.cost)[0];s=60+n.cost*5,e.logic.push(`Enables Play of '${n.name}' (Cost ${n.cost}): +${s}`)}else s=1,e.logic.push("No new cards enabled. Low priority.")}else if(t.effect.type==="DRAW"){const o=a.energy-t.cost;o>0?(s=10+o*2,e.logic.push(`(Base: 10) + (Energy Left: ${o} * 2)`)):(s=1,e.logic.push("Low Priority: 1"))}else if(t.effect.type==="SEARCH_AND_DRAW"){const o=a.energy-t.cost,c=t.effect.drawCount*12,n=t.effect.searchCount*2;o>=0?(s=c+n+o*2,e.logic.push(`(Draw Value: ${c}) + (Search Bonus: ${n}) + (Energy Left: ${o} * 2)`)):(s=2,e.logic.push("Low Priority: 2"))}else if(t.effect.type==="HEAL_SHIELDS"){const o=Math.min(t.effect.value,r.currentMaxShields-r.currentShields);s=o*5,e.logic.push(`(Shields Healed: ${o} * 5)`)}else if(t.effect.type==="HEAL_HULL"&&t.targeting.type==="SHIP_SECTION")s=80,e.logic.push("High Priority Section Heal: 80");else if(t.effect.type==="REPEATING_EFFECT"){let o=1;if(t.condition==="OWN_DAMAGED_SECTIONS")for(const c in a.shipSections){const n=a.shipSections[c],i=m(n);(i==="damaged"||i==="critical")&&o++}s=o*25-t.cost*4,e.logic.push(`(Repeats: ${o} * 25) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.type==="CREATE_TOKENS"){const o=Object.values(a.dronesOnBoard).flat(),c=o.reduce((u,h)=>u+(h.class||0),0),n=o.filter(u=>u.class>=3).length,d=["lane1","lane2","lane3"].filter(u=>!Y(a,u)).length,l=d/3;if(d===0)s=-999,e.logic.push("❌ No available lanes (all have Jammers)");else{const h=c*5,p=n*15,E=t.cost*4;s=(30+h+p-E)*l,e.logic.push("Base Value: 30"),e.logic.push(`CPU Protection: ${h} (${c} total CPU)`),e.logic.push(`High-Value Drones: ${p} (${n} drones)`),e.logic.push(`Cost: -${E}`),e.logic.push(`Available Lanes: ${d}/3 (${(l*100).toFixed(0)}% value)`)}}else if(t.effect.type==="MODIFY_STAT"){const{mod:o}=t.effect,{target:c}=e;if(t.targeting?.type==="LANE"){const n=c.id,d=(a.dronesOnBoard[n]||[]).filter(l=>!l.isExhausted);if(d.length===0)s=0,e.logic.push("No Active Drones in Lane");else{const l=P(n,a,f,N,m,g),u=JSON.parse(JSON.stringify(a));u.dronesOnBoard[n].forEach(E=>{E.isExhausted||(E.statMods||(E.statMods=[]),E.statMods.push(o))});const p=P(n,u,f,N,m,g)-l;s=p*1.5+d.length*10,e.logic.push(`Lane Impact: ${p.toFixed(0)}`),e.logic.push(`Multi-Buff Bonus: ${d.length*10}`)}}else if(o.stat==="attack"&&o.value>0)c.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=c.class*10+o.value*8,e.logic.push(`Target Class: ${c.class*10}`),e.logic.push(`Attack Value: ${o.value*8}`));else if(o.stat==="attack"&&o.value<0)if(c.isExhausted)s=-1,e.logic.push("Invalid Target (Already Exhausted)");else{const n=g.getEffectiveStats(c,I(c.id,f));s=n.attack*8-o.value*-5,e.logic.push(`Threat Reduction: ${n.attack*8}`)}else if(o.stat==="speed"&&o.value>0)if(c.isExhausted)s=-1,e.logic.push("Invalid (Exhausted)");else{const n=I(c.id,a),i=f.dronesOnBoard[n]||[],d=i.length>0?Math.max(...i.map(u=>g.getEffectiveStats(u,n).speed)):-1,l=g.getEffectiveStats(c,n);l.speed<=d&&l.speed+o.value>d?(s=60,e.logic.push("Interceptor Overcome Bonus: 60")):(s=20,e.logic.push("Utility Speed Bonus: 20"))}else c.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=10,e.logic.push("Generic stat modification"));s>0&&(o.type==="permanent"&&(s*=1.5,e.logic.push("Permanent Mod x1.5")),t.effect.goAgain&&(s+=40,e.logic.push("Go Again Bonus: +40")),s-=t.cost*4,e.logic.push(`Cost: -${t.cost*4}`))}e.score=s;break}case"attack":{const{attacker:t,target:r,targetType:o}=e,c=g.getEffectiveStats(t,t.lane),n=Math.max(0,c.attack);if(o==="drone"){const i=g.getEffectiveStats(r,t.lane);if(s=i.class*10,e.logic.push(`(Target Class: ${i.class} * 10)`),c.class<i.class&&(s+=20,e.logic.push("Favorable Trade Bonus: 20")),r.isExhausted||(s+=10,e.logic.push("Ready Target Bonus: 10")),j.find(u=>u.name===t.name)?.abilities.some(u=>u.type==="PASSIVE"&&u.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(s-=40,e.logic.push("Anti-Ship Penalty: -40")),t.damageType==="PIERCING"){const u=i.currentShields*8;s+=u,e.logic.push(`Piercing Bonus: ${u}`)}}else if(o==="section"){s=n*8,e.logic.push(`(Effective Attack: ${n} * 8)`);const i=m(r);if(i==="damaged"&&(s+=15,e.logic.push("Damaged Section Bonus: 15")),i==="critical"&&(s+=30,e.logic.push("Critical Section Bonus: 30")),r.allocatedShields===0?(s+=40,e.logic.push("No Shields Bonus: 40")):n>=r.allocatedShields&&(s+=35,e.logic.push("Shield Break Bonus: 35")),n>=3&&(s+=10,e.logic.push("High Attack Bonus: 10")),t.damageType==="PIERCING"){const d=r.allocatedShields*10;s+=d,e.logic.push(`Piercing Bonus: ${d}`)}}e.score=s;break}case"move":{const{drone:t,fromLane:r,toLane:o}=e;e.instigator=t.name,e.targetName=o;const c=P(r,a,f,N,m,g),n=P(o,a,f,N,m,g),i=JSON.parse(JSON.stringify(a)),d=i.dronesOnBoard[r].find(T=>T.id===t.id);d&&(i.dronesOnBoard[r]=i.dronesOnBoard[r].filter(T=>T.id!==t.id),i.dronesOnBoard[o].push(d));const l=P(r,i,f,N,m,g),h=P(o,i,f,N,m,g)-n,p=l-c,E=10;s=h+p-E,e.logic.push(`ToLane Impact: ${h.toFixed(0)}`),e.logic.push(`FromLane Impact: ${p.toFixed(0)}`),e.logic.push(`Move Cost: -${E}`);const $=parseInt(o.slice(-1))-1,M=v[$];if(M){const T=m(a.shipSections[M]);(T==="damaged"||T==="critical")&&n<0&&(s+=25,e.logic.push("Defensive Bonus: +25"))}const w=A[$];if(w){const H=j.find(C=>C.name===t.name)?.abilities.find(C=>C.type==="TRIGGERED"&&C.trigger==="ON_MOVE");if(H){let C=0;H.effects?.forEach(S=>{S.type==="PERMANENT_STAT_MOD"&&(S.mod.stat==="attack"&&(C+=S.mod.value*15),S.mod.stat==="speed"&&(C+=S.mod.value*10))}),s+=C,e.logic.push(`OnMove Bonus: +${C}`)}const V=m(f.shipSections[w]);n>0&&(V==="damaged"?(s+=20,e.logic.push("Offensive Bonus (Damaged Section): +20")):V==="critical"&&(s-=150,e.logic.push("Overkill Penalty (Critical Section): -150")))}e.score=s;break}}});const B={lane1:0,lane2:0,lane3:0};y.forEach(e=>{if(e.type==="play_card"&&e.target?.owner==="player1"){const s=I(e.target.id,f);s&&Y(f,s)&&(U(e.target)||(B[s]+=e.score>0?e.score:0,e.score=-999,e.logic.push("❌ BLOCKED BY JAMMER")))}}),y.forEach(e=>{if(e.type==="attack"&&e.targetType==="drone"&&U(e.target)){const s=e.attacker.lane,t=B[s];t>0&&(e.score+=t,e.logic.push(`Jammer Removal: +${t.toFixed(0)} (unblocks cards)`)),g.getEffectiveStats(e.attacker,s).attack<=2&&t>0&&(e.score+=30,e.logic.push("Efficient Trade: +30"))}});const _=y.length>0?Math.max(...y.map(e=>e.score)):0;if(_<=0)return D({player:a.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during action phase."},"aiActionPass",y),{type:"pass"};const R=y.filter(e=>e.score>=_-20).filter(e=>e.score>0),G=R[Math.floor(Math.random()*R.length)];return G.isChosen=!0,{type:"action",payload:G,logContext:y}},Q=(f,a)=>{if(!f||f.length===0)return{interceptor:null};const v=[...f].sort((b,k)=>{const D=b.class??1/0,g=k.class??1/0;return D-g})[0],m=a.class??1/0,I=v.class??1/0;return m===void 0||I<m?{interceptor:v}:{interceptor:null}},Z={handleOpponentTurn:q,handleOpponentAction:z,makeInterceptionDecision:Q};export{Z as aiBrain};
