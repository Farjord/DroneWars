import{G as Y,f as U,d as j}from"./index-Dj0YNUqb.js";const J=f=>f.abilities?.some(c=>c.effect?.type==="GRANT_KEYWORD"&&c.effect?.keyword==="JAMMER"),W=(f,c)=>(f.dronesOnBoard[c]||[]).some(J),P=(f,c,v,D,p,A)=>{const k=c.dronesOnBoard[f]||[],b=v.dronesOnBoard[f]||[],I=parseInt(f.slice(-1))-1,g=(e,s,t,a)=>e.reduce((o,i)=>{const n=A.getEffectiveStats(i,f),r=(n.attack||0)+(n.potentialShipDamage||0);return o+r+(i.hull||0)+(i.currentShields||0)},0),C=g(k),E=g(b),M=C-E,O=(e,s,t,a)=>e.length===0?0:Math.max(...e.map(o=>A.getEffectiveStats(o,f).speed)),w=O(k),B=O(b),_=(w-B)*5;let $=0;const R=D.player2[I];if(R){const e=p(c.shipSections[R]);e==="damaged"&&($-=20),e==="critical"&&($-=40)}const G=D.player1[I];if(G){const e=p(v.shipSections[G]);e==="damaged"&&($+=15),e==="critical"&&($+=30)}return M+_+$},K=({player1:f,player2:c,turn:v,placedSections:D,opponentPlacedSections:p,getShipStatus:A,gameStateManager:k,addLogEntry:b})=>{const I=Y.getInstance(k),g=I.getEffectiveShipStats(c,p).totals,C=Object.values(c.dronesOnBoard).flat().length,E=v===1?c.initialDeploymentBudget+c.energy:c.deploymentBudget+c.energy,M=[...c.hand].sort((t,a)=>a.cost-t.cost),O=M[0]?.cost||0;j("AI_DECISIONS","[AI ENERGY DEBUG] Deployment energy management:",{currentEnergy:c.energy,cardsInHand:c.hand.map(t=>({name:t.name,cost:t.cost})),mostExpensiveCard:M[0]?.name||"None",deploymentBudget:v===1?c.initialDeploymentBudget:c.deploymentBudget});const w=c.activeDronePool,B=[],_=["lane1","lane2","lane3"],$={player1:D,player2:p},R={lane1:P("lane1",c,f,$,A,I),lane2:P("lane2",c,f,$,A,I),lane3:P("lane3",c,f,$,A,I)};for(const t of w){const a=t.class;let o=!0,i="";if(E<a)o=!1,i="Insufficient total resources";else if((c.deployedDroneCounts[t.name]||0)>=t.limit)o=!1,i="Deployment limit reached";else if(C>=g.cpuLimit)o=!1,i="CPU limit reached";else{const n=v===1?c.initialDeploymentBudget:c.deploymentBudget,r=Math.min(n,a),d=a-r,l=c.energy-d;l<O?(o=!1,i=`Reserves energy for cards (needs ${O})`,j("AI_DECISIONS",`[AI ENERGY DEBUG] ${t.name} rejected: energy after deployment (${l}) < reserved (${O})`)):j("AI_DECISIONS",`[AI ENERGY DEBUG] ${t.name} affordable: energy after deployment (${l}) >= reserved (${O})`)}if(!o){B.push({drone:t,laneId:"N/A",score:-999,instigator:t.name,targetName:"N/A",logic:[i]});continue}for(const n of _){const r=JSON.parse(JSON.stringify(c)),d=U.find(y=>y.name===t.name);r.dronesOnBoard[n].push({...d,id:"temp"});const l=P(n,r,f,$,A,I),u=l-R[n];let h=0;const m=R[n],S=new Set(d.abilities.filter(y=>y.effect.keyword).map(y=>y.effect.keyword));m<-15?(t.speed>=4&&(h+=15),(S.has("ALWAYS_INTERCEPTS")||S.has("GUARDIAN"))&&(h+=20)):m>15?(t.attack>=4&&(h+=15),d.abilities.some(y=>y.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(h+=20)):t.class<=1&&(h+=10);let T=0;m<0&&l>=0&&(T=Math.floor(Math.random()*21)+10);let x=0;l>20&&m<=20&&(x=Math.floor(Math.random()*21)+10);const F=[`LaneScore: ${m.toFixed(0)}`,`Projected: ${l.toFixed(0)}`,`Impact: ${u.toFixed(0)}`,`Bonus: ${h.toFixed(0)}`,`Stabilize: ${T.toFixed(0)}`,`Dominance: ${x.toFixed(0)}`];let L=0;const H=parseInt(n.slice(-1))-1,V=D[H];if(V){const y=A(f.shipSections[V]);(y==="damaged"||y==="critical")&&m>5&&(L=-150,F.push(`Overkill Penalty: ${L}`))}const N=u+h+T+x+L;B.push({drone:t,laneId:n,score:N,instigator:t.name,targetName:n,logic:F})}}const G=B.length>0?Math.max(...B.map(t=>t.score)):-1;if(G<5)return b({player:c.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during deployment phase (no high-impact plays)."},"aiDeploymentPass",B),{type:"pass"};const e=B.filter(t=>t.score===G),s=e[Math.floor(Math.random()*e.length)];return s.isChosen=!0,{type:"deploy",payload:{droneToDeploy:s.drone,targetLane:s.laneId,logContext:B}}},q=({player1:f,player2:c,placedSections:v,opponentPlacedSections:D,getShipStatus:p,getLaneOfDrone:A,gameStateManager:k,getValidTargets:b,addLogEntry:I})=>{const g=Y.getInstance(k),C={player1:v,player2:D},E=[],M=new Set,O=Object.entries(c.dronesOnBoard).flatMap(([e,s])=>s.filter(t=>!t.isExhausted).map(t=>({...t,lane:e}))),w=c.hand.filter(e=>c.energy>=e.cost);for(const e of w)if(e.targeting){let s=b("player2",null,e,f,c);e.effect.type==="HEAL_SHIELDS"&&(s=s.filter(t=>t.currentShields<t.currentMaxShields)),e.effect.type==="HEAL_HULL"&&e.targeting.type==="SHIP_SECTION"&&(s=s.filter(t=>t.hull<t.maxHull)),(e.effect.type==="DAMAGE"||e.effect.type==="DESTROY")&&(s=s.filter(t=>t.owner==="player1"));for(const t of s){const a=`card-${e.id}-${t.id}-${t.owner}`;M.has(a)||(E.push({type:"play_card",card:e,target:t,score:0}),M.add(a))}}else{const s=`card-${e.id}`;M.has(s)||(E.push({type:"play_card",card:e,target:null,score:0}),M.add(s))}for(const e of O){const s=f.dronesOnBoard[e.lane];for(const o of s)E.push({type:"attack",attacker:e,target:{...o,owner:"player1"},targetType:"drone",score:0});const t=parseInt(e.lane.slice(-1))-1,a=v[t];if(a&&f.shipSections[a].hull>0&&!f.dronesOnBoard[e.lane].some(n=>g.getEffectiveStats(n,e.lane).keywords.has("GUARDIAN"))){const n={...f.shipSections[a],id:a,name:a,owner:"player1"};E.push({type:"attack",attacker:e,target:n,targetType:"section",score:0})}}for(const e of O){const s=parseInt(e.lane.slice(-1));[s-1,s+1].forEach(t=>{if(t>=1&&t<=3){const a=`lane${t}`;E.push({type:"move",drone:e,fromLane:e.lane,toLane:a,score:0})}})}E.forEach(e=>{e.instigator=e.card?.name||e.attacker?.name,e.targetName=e.target?.name||e.target?.id||"N/A",e.logic=[];let s=0;switch(e.type){case"play_card":{const{card:t,target:a}=e;if(t.effect.type==="DESTROY"){if(t.effect.scope==="SINGLE"&&a){const o=(a.hull||0)+(a.currentShields||0);s=o*8-t.cost*4,e.logic.push(`(Target Value: ${o} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="FILTERED"&&a&&a.id.startsWith("lane")){const{stat:o,comparison:i,value:n}=t.effect.filter,r=f.dronesOnBoard[a.id]||[];let d=0;r.forEach(l=>{let u=!1;i==="GTE"&&l[o]>=n&&(u=!0),i==="LTE"&&l[o]<=n&&(u=!0),u&&(d+=(l.hull||0)+(l.currentShields||0)+l.class*5)}),s=d*8-t.cost*4,e.logic.push(`(Filtered Value: ${d} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="LANE"&&a&&a.id.startsWith("lane")){const o=a.id,i=f.dronesOnBoard[o]||[],n=c.dronesOnBoard[o]||[],r=m=>m.reduce((S,T)=>{const x=(T.hull||0)+(T.currentShields||0)+T.class*5;return S+(T.isExhausted?x:x*1.5)},0),d=r(i),l=r(n),u=4,h=t.cost*4;s=(d-l)*u-h,e.logic.push(`((Enemy Val: ${d.toFixed(0)} - Friendly Val: ${l.toFixed(0)}) * ${u}) - Cost: ${h}`)}}else if(t.effect.type==="DAMAGE"&&a)if(t.effect.scope==="FILTERED"&&a.id.startsWith("lane")&&t.effect.filter){const{stat:o,comparison:i,value:n}=t.effect.filter,r=f.dronesOnBoard[a.id]||[];let d=0,l=0;const u=a.id;r.forEach(h=>{const m=g.getEffectiveStats(h,u);let S=!1;i==="GTE"&&m[o]>=n&&(S=!0),i==="LTE"&&m[o]<=n&&(S=!0),S&&(l++,d+=t.effect.value)}),s=d*10+(l>1?l*15:0)-t.cost*4,e.logic.push(`(Filtered Damage: ${d} * 10) + (Multi-Hit Bonus: ${l>1?l*15:0}) - (Card Cost: ${t.cost} * 4)`)}else{let o=t.effect.value,i=[];if(t.effect.damageType==="PIERCING"){const l=a.currentShields||0;i.push(`Piercing bypasses ${l} shields`)}const n=t.effect.value*8;i.push(`Base Dmg: ${n}`);let r=n;if(o>=a.hull){const l=a.class*15+50;r+=l,i.push(`Lethal Bonus: +${l}`)}const d=t.cost*4;r-=d,i.push(`Cost: -${d}`),s=r,e.logic.push(...i.map(l=>`(${l})`))}else if(t.effect.type==="READY_DRONE")s=a.class*12;else if(t.effect.type==="GAIN_ENERGY"){const o=c.energy-t.cost+t.effect.value;e.logic.push(`Projected Energy: ${o}`);const i=c.hand.filter(n=>n.instanceId!==t.instanceId&&c.energy<n.cost&&o>=n.cost);if(i.length>0){const n=i.sort((r,d)=>d.cost-r.cost)[0];s=60+n.cost*5,e.logic.push(`Enables Play of '${n.name}' (Cost ${n.cost}): +${s}`)}else s=1,e.logic.push("No new cards enabled. Low priority.")}else if(t.effect.type==="DRAW"){const o=c.energy-t.cost;o>0?(s=10+o*2,e.logic.push(`(Base: 10) + (Energy Left: ${o} * 2)`)):(s=1,e.logic.push("Low Priority: 1"))}else if(t.effect.type==="SEARCH_AND_DRAW"){const o=c.energy-t.cost,i=t.effect.drawCount*12,n=t.effect.searchCount*2;o>=0?(s=i+n+o*2,e.logic.push(`(Draw Value: ${i}) + (Search Bonus: ${n}) + (Energy Left: ${o} * 2)`)):(s=2,e.logic.push("Low Priority: 2"))}else if(t.effect.type==="HEAL_SHIELDS"){const o=Math.min(t.effect.value,a.currentMaxShields-a.currentShields);s=o*5,e.logic.push(`(Shields Healed: ${o} * 5)`)}else if(t.effect.type==="HEAL_HULL"&&t.targeting.type==="SHIP_SECTION")s=80,e.logic.push("High Priority Section Heal: 80");else if(t.effect.type==="REPEATING_EFFECT"){let o=1;if(t.condition==="OWN_DAMAGED_SECTIONS")for(const i in c.shipSections){const n=c.shipSections[i],r=p(n);(r==="damaged"||r==="critical")&&o++}s=o*25-t.cost*4,e.logic.push(`(Repeats: ${o} * 25) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.type==="CREATE_TOKENS"){const o=Object.values(c.dronesOnBoard).flat(),i=o.reduce((h,m)=>h+(m.class||0),0),n=o.filter(h=>h.class>=3).length,r=30,d=i*5,l=n*15,u=t.cost*4;s=r+d+l-u,e.logic.push(`Base Value: ${r}`),e.logic.push(`CPU Protection: ${d} (${i} total CPU)`),e.logic.push(`High-Value Drones: ${l} (${n} drones)`),e.logic.push(`Cost: -${u}`)}else if(t.effect.type==="MODIFY_STAT"){const{mod:o}=t.effect,{target:i}=e;if(t.targeting?.type==="LANE"){const n=i.id,d=(c.dronesOnBoard[n]||[]).filter(l=>!l.isExhausted);if(d.length===0)s=0,e.logic.push("No Active Drones in Lane");else{const l=P(n,c,f,C,p,g),u=JSON.parse(JSON.stringify(c));u.dronesOnBoard[n].forEach(S=>{S.isExhausted||(S.statMods||(S.statMods=[]),S.statMods.push(o))});const m=P(n,u,f,C,p,g)-l;s=m*1.5+d.length*10,e.logic.push(`Lane Impact: ${m.toFixed(0)}`),e.logic.push(`Multi-Buff Bonus: ${d.length*10}`)}}else if(o.stat==="attack"&&o.value>0)i.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=i.class*10+o.value*8,e.logic.push(`Target Class: ${i.class*10}`),e.logic.push(`Attack Value: ${o.value*8}`));else if(o.stat==="attack"&&o.value<0)if(i.isExhausted)s=-1,e.logic.push("Invalid Target (Already Exhausted)");else{const n=g.getEffectiveStats(i,A(i.id,f));s=n.attack*8-o.value*-5,e.logic.push(`Threat Reduction: ${n.attack*8}`)}else if(o.stat==="speed"&&o.value>0)if(i.isExhausted)s=-1,e.logic.push("Invalid (Exhausted)");else{const n=A(i.id,c),r=f.dronesOnBoard[n]||[],d=r.length>0?Math.max(...r.map(u=>g.getEffectiveStats(u,n).speed)):-1,l=g.getEffectiveStats(i,n);l.speed<=d&&l.speed+o.value>d?(s=60,e.logic.push("Interceptor Overcome Bonus: 60")):(s=20,e.logic.push("Utility Speed Bonus: 20"))}else i.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=10,e.logic.push("Generic stat modification"));s>0&&(o.type==="permanent"&&(s*=1.5,e.logic.push("Permanent Mod x1.5")),t.effect.goAgain&&(s+=40,e.logic.push("Go Again Bonus: +40")),s-=t.cost*4,e.logic.push(`Cost: -${t.cost*4}`))}e.score=s;break}case"attack":{const{attacker:t,target:a,targetType:o}=e,i=g.getEffectiveStats(t,t.lane),n=Math.max(0,i.attack);if(o==="drone"){const r=g.getEffectiveStats(a,t.lane);if(s=r.class*10,e.logic.push(`(Target Class: ${r.class} * 10)`),i.class<r.class&&(s+=20,e.logic.push("Favorable Trade Bonus: 20")),a.isExhausted||(s+=10,e.logic.push("Ready Target Bonus: 10")),U.find(u=>u.name===t.name)?.abilities.some(u=>u.type==="PASSIVE"&&u.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(s-=40,e.logic.push("Anti-Ship Penalty: -40")),t.damageType==="PIERCING"){const u=r.currentShields*8;s+=u,e.logic.push(`Piercing Bonus: ${u}`)}}else if(o==="section"){s=n*8,e.logic.push(`(Effective Attack: ${n} * 8)`);const r=p(a);if(r==="damaged"&&(s+=15,e.logic.push("Damaged Section Bonus: 15")),r==="critical"&&(s+=30,e.logic.push("Critical Section Bonus: 30")),a.allocatedShields===0?(s+=40,e.logic.push("No Shields Bonus: 40")):n>=a.allocatedShields&&(s+=35,e.logic.push("Shield Break Bonus: 35")),n>=3&&(s+=10,e.logic.push("High Attack Bonus: 10")),t.damageType==="PIERCING"){const d=a.allocatedShields*10;s+=d,e.logic.push(`Piercing Bonus: ${d}`)}}e.score=s;break}case"move":{const{drone:t,fromLane:a,toLane:o}=e;e.instigator=t.name,e.targetName=o;const i=P(a,c,f,C,p,g),n=P(o,c,f,C,p,g),r=JSON.parse(JSON.stringify(c)),d=r.dronesOnBoard[a].find(L=>L.id===t.id);d&&(r.dronesOnBoard[a]=r.dronesOnBoard[a].filter(L=>L.id!==t.id),r.dronesOnBoard[o].push(d));const l=P(a,r,f,C,p,g),h=P(o,r,f,C,p,g)-n,m=l-i,S=10;s=h+m-S,e.logic.push(`ToLane Impact: ${h.toFixed(0)}`),e.logic.push(`FromLane Impact: ${m.toFixed(0)}`),e.logic.push(`Move Cost: -${S}`);const T=parseInt(o.slice(-1))-1,x=D[T];if(x){const L=p(c.shipSections[x]);(L==="damaged"||L==="critical")&&n<0&&(s+=25,e.logic.push("Defensive Bonus: +25"))}const F=v[T];if(F){const H=U.find(N=>N.name===t.name)?.abilities.find(N=>N.type==="TRIGGERED"&&N.trigger==="ON_MOVE");if(H){let N=0;H.effects?.forEach(y=>{y.type==="PERMANENT_STAT_MOD"&&(y.mod.stat==="attack"&&(N+=y.mod.value*15),y.mod.stat==="speed"&&(N+=y.mod.value*10))}),s+=N,e.logic.push(`OnMove Bonus: +${N}`)}const V=p(f.shipSections[F]);n>0&&(V==="damaged"?(s+=20,e.logic.push("Offensive Bonus (Damaged Section): +20")):V==="critical"&&(s-=150,e.logic.push("Overkill Penalty (Critical Section): -150")))}e.score=s;break}}});const B={lane1:0,lane2:0,lane3:0};E.forEach(e=>{if(e.type==="play_card"&&e.target?.owner==="player1"){const s=A(e.target.id,f);s&&W(f,s)&&(J(e.target)||(B[s]+=e.score>0?e.score:0,e.score=-999,e.logic.push("❌ BLOCKED BY JAMMER")))}}),E.forEach(e=>{if(e.type==="attack"&&e.targetType==="drone"&&J(e.target)){const s=e.attacker.lane,t=B[s];t>0&&(e.score+=t,e.logic.push(`Jammer Removal: +${t.toFixed(0)} (unblocks cards)`)),g.getEffectiveStats(e.attacker,s).attack<=2&&t>0&&(e.score+=30,e.logic.push("Efficient Trade: +30"))}});const _=E.length>0?Math.max(...E.map(e=>e.score)):0;if(_<=0)return I({player:c.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during action phase."},"aiActionPass",E),{type:"pass"};const R=E.filter(e=>e.score>=_-20).filter(e=>e.score>0),G=R[Math.floor(Math.random()*R.length)];return G.isChosen=!0,{type:"action",payload:G,logContext:E}},z=(f,c)=>{if(!f||f.length===0)return{interceptor:null};const D=[...f].sort((k,b)=>{const I=k.class??1/0,g=b.class??1/0;return I-g})[0],p=c.class??1/0,A=D.class??1/0;return p===void 0||A<p?{interceptor:D}:{interceptor:null}},X={handleOpponentTurn:K,handleOpponentAction:q,makeInterceptionDecision:z};export{X as aiBrain};
