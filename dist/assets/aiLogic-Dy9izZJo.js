import{G as U,f as j}from"./index-CIN8OfeG.js";const C=(u,r,v,M,m,I)=>{const G=r.dronesOnBoard[u]||[],R=v.dronesOnBoard[u]||[],$=parseInt(u.slice(-1))-1,h=(s,t,o,n)=>s.reduce((c,a)=>{const i=I.getEffectiveStats(a,u),f=(i.attack||0)+(i.potentialShipDamage||0);return c+f+(a.hull||0)+(a.currentShields||0)},0),L=h(G),E=h(R),O=L-E,D=(s,t,o,n)=>s.length===0?0:Math.max(...s.map(c=>I.getEffectiveStats(c,u).speed)),w=D(G),y=D(R),H=(w-y)*5;let S=0;const b=M.player2[$];if(b){const s=m(r.shipSections[b]);s==="damaged"&&(S-=20),s==="critical"&&(S-=40)}const e=M.player1[$];if(e){const s=m(v.shipSections[e]);s==="damaged"&&(S+=15),s==="critical"&&(S+=30)}return O+H+S},Y=({player1:u,player2:r,turn:v,placedSections:M,opponentPlacedSections:m,getShipStatus:I,gameStateManager:G,addLogEntry:R})=>{const $=U.getInstance(G),h=$.getEffectiveShipStats(r,m).totals,L=Object.values(r.dronesOnBoard).flat().length,E=v===1?r.initialDeploymentBudget+r.energy:r.deploymentBudget+r.energy,O=[...r.hand].sort((o,n)=>n.cost-o.cost),D=O[0]?.cost||0;console.log("[AI ENERGY DEBUG] Deployment energy management:",{currentEnergy:r.energy,reservedEnergy:D,cardsInHand:r.hand.map(o=>({name:o.name,cost:o.cost})),mostExpensiveCard:O[0]?.name||"None",turn:v,deploymentBudget:v===1?r.initialDeploymentBudget:r.deploymentBudget});const w=r.activeDronePool,y=[],H=["lane1","lane2","lane3"],S={player1:M,player2:m},b={lane1:C("lane1",r,u,S,I,$),lane2:C("lane2",r,u,S,I,$),lane3:C("lane3",r,u,S,I,$)};for(const o of w){const n=o.class;let c=!0,a="";if(E<n)c=!1,a="Insufficient total resources";else if((r.deployedDroneCounts[o.name]||0)>=o.limit)c=!1,a="Deployment limit reached";else if(L>=h.cpuLimit)c=!1,a="CPU limit reached";else{const i=v===1?r.initialDeploymentBudget:r.deploymentBudget,f=Math.min(i,n),l=n-f,d=r.energy-l;d<D?(c=!1,a=`Reserves energy for cards (needs ${D})`,console.log(`[AI ENERGY DEBUG] ${o.name} rejected: energy after deployment (${d}) < reserved (${D})`)):console.log(`[AI ENERGY DEBUG] ${o.name} affordable: energy after deployment (${d}) >= reserved (${D})`)}if(!c){y.push({drone:o,laneId:"N/A",score:-999,instigator:o.name,targetName:"N/A",logic:[a]});continue}for(const i of H){const f=JSON.parse(JSON.stringify(r)),l=j.find(x=>x.name===o.name);f.dronesOnBoard[i].push({...l,id:"temp"});const d=C(i,f,u,S,I,$),B=d-b[i];let p=0;const g=b[i],T=new Set(l.abilities.filter(x=>x.effect.keyword).map(x=>x.effect.keyword));g<-15?(o.speed>=4&&(p+=15),(T.has("ALWAYS_INTERCEPTS")||T.has("GUARDIAN"))&&(p+=20)):g>15?(o.attack>=4&&(p+=15),l.abilities.some(x=>x.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(p+=20)):o.class<=1&&(p+=10);let P=0;g<0&&d>=0&&(P=Math.floor(Math.random()*21)+10);let _=0;d>20&&g<=20&&(_=Math.floor(Math.random()*21)+10);const N=[`LaneScore: ${g.toFixed(0)}`,`Projected: ${d.toFixed(0)}`,`Impact: ${B.toFixed(0)}`,`Bonus: ${p.toFixed(0)}`,`Stabilize: ${P.toFixed(0)}`,`Dominance: ${_.toFixed(0)}`];let F=0;const V=parseInt(i.slice(-1))-1,A=M[V];if(A){const x=I(u.shipSections[A]);(x==="damaged"||x==="critical")&&g>5&&(F=-150,N.push(`Overkill Penalty: ${F}`))}const k=B+p+P+_+F;y.push({drone:o,laneId:i,score:k,instigator:o.name,targetName:i,logic:N})}}const e=y.length>0?Math.max(...y.map(o=>o.score)):-1;if(e<5)return R({player:r.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during deployment phase (no high-impact plays)."},"aiDeploymentPass",y),{type:"pass"};const s=y.filter(o=>o.score===e),t=s[Math.floor(Math.random()*s.length)];return t.isChosen=!0,{type:"deploy",payload:{droneToDeploy:t.drone,targetLane:t.laneId,logContext:y}}},W=({player1:u,player2:r,placedSections:v,opponentPlacedSections:M,getShipStatus:m,getLaneOfDrone:I,gameStateManager:G,getValidTargets:R,addLogEntry:$})=>{const h=U.getInstance(G),L={player1:v,player2:M},E=[],O=new Set,D=Object.entries(r.dronesOnBoard).flatMap(([e,s])=>s.filter(t=>!t.isExhausted).map(t=>({...t,lane:e}))),w=r.hand.filter(e=>r.energy>=e.cost);for(const e of w)if(e.targeting){let s=R("player2",null,e,u,r);e.effect.type==="HEAL_SHIELDS"&&(s=s.filter(t=>t.currentShields<t.currentMaxShields)),e.effect.type==="HEAL_HULL"&&e.targeting.type==="SHIP_SECTION"&&(s=s.filter(t=>t.hull<t.maxHull)),(e.effect.type==="DAMAGE"||e.effect.type==="DESTROY")&&(s=s.filter(t=>t.owner==="player1"));for(const t of s){const o=`card-${e.id}-${t.id}-${t.owner}`;O.has(o)||(E.push({type:"play_card",card:e,target:t,score:0}),O.add(o))}}else{const s=`card-${e.id}`;O.has(s)||(E.push({type:"play_card",card:e,target:null,score:0}),O.add(s))}for(const e of D){const s=u.dronesOnBoard[e.lane];for(const n of s)E.push({type:"attack",attacker:e,target:{...n,owner:"player1"},targetType:"drone",score:0});const t=parseInt(e.lane.slice(-1))-1,o=v[t];if(o&&u.shipSections[o].hull>0&&!u.dronesOnBoard[e.lane].some(a=>h.getEffectiveStats(a,e.lane).keywords.has("GUARDIAN"))){const a={id:o,name:o,...u.shipSections[o],owner:"player1"};E.push({type:"attack",attacker:e,target:a,targetType:"section",score:0})}}for(const e of D){const s=parseInt(e.lane.slice(-1));[s-1,s+1].forEach(t=>{if(t>=1&&t<=3){const o=`lane${t}`;E.push({type:"move",drone:e,fromLane:e.lane,toLane:o,score:0})}})}E.forEach(e=>{e.instigator=e.card?.name||e.attacker?.name,e.targetName=e.target?.name||e.target?.id||"N/A",e.logic=[];let s=0;switch(e.type){case"play_card":{const{card:t,target:o}=e;if(t.effect.type==="DESTROY"){if(t.effect.scope==="SINGLE"&&o){const n=(o.hull||0)+(o.currentShields||0);s=n*8-t.cost*4,e.logic.push(`(Target Value: ${n} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="FILTERED"&&o&&o.id.startsWith("lane")){const{stat:n,comparison:c,value:a}=t.effect.filter,i=u.dronesOnBoard[o.id]||[];let f=0;i.forEach(l=>{let d=!1;c==="GTE"&&l[n]>=a&&(d=!0),c==="LTE"&&l[n]<=a&&(d=!0),d&&(f+=(l.hull||0)+(l.currentShields||0)+l.class*5)}),s=f*8-t.cost*4,e.logic.push(`(Filtered Value: ${f} * 8) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.scope==="LANE"&&o&&o.id.startsWith("lane")){const n=o.id,c=u.dronesOnBoard[n]||[],a=r.dronesOnBoard[n]||[],i=p=>p.reduce((g,T)=>{const P=(T.hull||0)+(T.currentShields||0)+T.class*5;return g+(T.isExhausted?P:P*1.5)},0),f=i(c),l=i(a),d=4,B=t.cost*4;s=(f-l)*d-B,e.logic.push(`((Enemy Val: ${f.toFixed(0)} - Friendly Val: ${l.toFixed(0)}) * ${d}) - Cost: ${B}`)}}else if(t.effect.type==="DAMAGE"&&o)if(t.effect.scope==="FILTERED"&&o.id.startsWith("lane")&&t.effect.filter){const{stat:n,comparison:c,value:a}=t.effect.filter,i=u.dronesOnBoard[o.id]||[];let f=0,l=0;const d=o.id;i.forEach(B=>{const p=h.getEffectiveStats(B,d);let g=!1;c==="GTE"&&p[n]>=a&&(g=!0),c==="LTE"&&p[n]<=a&&(g=!0),g&&(l++,f+=t.effect.value)}),s=f*10+(l>1?l*15:0)-t.cost*4,e.logic.push(`(Filtered Damage: ${f} * 10) + (Multi-Hit Bonus: ${l>1?l*15:0}) - (Card Cost: ${t.cost} * 4)`)}else{let n=t.effect.value,c=[];if(t.effect.damageType==="PIERCING"){const l=o.currentShields||0;c.push(`Piercing bypasses ${l} shields`)}const a=t.effect.value*8;c.push(`Base Dmg: ${a}`);let i=a;if(n>=o.hull){const l=o.class*15+50;i+=l,c.push(`Lethal Bonus: +${l}`)}const f=t.cost*4;i-=f,c.push(`Cost: -${f}`),s=i,e.logic.push(...c.map(l=>`(${l})`))}else if(t.effect.type==="READY_DRONE")s=o.class*12;else if(t.effect.type==="GAIN_ENERGY"){const n=r.energy-t.cost+t.effect.value;e.logic.push(`Projected Energy: ${n}`);const c=r.hand.filter(a=>a.instanceId!==t.instanceId&&r.energy<a.cost&&n>=a.cost);if(c.length>0){const a=c.sort((i,f)=>f.cost-i.cost)[0];s=60+a.cost*5,e.logic.push(`Enables Play of '${a.name}' (Cost ${a.cost}): +${s}`)}else s=1,e.logic.push("No new cards enabled. Low priority.")}else if(t.effect.type==="DRAW"){const n=r.energy-t.cost;n>0?(s=10+n*2,e.logic.push(`(Base: 10) + (Energy Left: ${n} * 2)`)):(s=1,e.logic.push("Low Priority: 1"))}else if(t.effect.type==="SEARCH_AND_DRAW"){const n=r.energy-t.cost,c=t.effect.drawCount*12,a=t.effect.searchCount*2;n>=0?(s=c+a+n*2,e.logic.push(`(Draw Value: ${c}) + (Search Bonus: ${a}) + (Energy Left: ${n} * 2)`)):(s=2,e.logic.push("Low Priority: 2"))}else if(t.effect.type==="HEAL_SHIELDS"){const n=Math.min(t.effect.value,o.currentMaxShields-o.currentShields);s=n*5,e.logic.push(`(Shields Healed: ${n} * 5)`)}else if(t.effect.type==="HEAL_HULL"&&t.targeting.type==="SHIP_SECTION")s=80,e.logic.push("High Priority Section Heal: 80");else if(t.effect.type==="REPEATING_EFFECT"){let n=1;if(t.condition==="OWN_DAMAGED_SECTIONS")for(const c in r.shipSections){const a=r.shipSections[c],i=m(a);(i==="damaged"||i==="critical")&&n++}s=n*25-t.cost*4,e.logic.push(`(Repeats: ${n} * 25) - (Card Cost: ${t.cost} * 4)`)}else if(t.effect.type==="MODIFY_STAT"){const{mod:n}=t.effect,{target:c}=e;if(t.targeting?.type==="LANE"){const a=c.id,f=(r.dronesOnBoard[a]||[]).filter(l=>!l.isExhausted);if(f.length===0)s=0,e.logic.push("No Active Drones in Lane");else{const l=C(a,r,u,L,m,h),d=JSON.parse(JSON.stringify(r));d.dronesOnBoard[a].forEach(g=>{g.isExhausted||(g.statMods||(g.statMods=[]),g.statMods.push(n))});const p=C(a,d,u,L,m,h)-l;s=p*1.5+f.length*10,e.logic.push(`Lane Impact: ${p.toFixed(0)}`),e.logic.push(`Multi-Buff Bonus: ${f.length*10}`)}}else if(n.stat==="attack"&&n.value>0)c.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=c.class*10+n.value*8,e.logic.push(`Target Class: ${c.class*10}`),e.logic.push(`Attack Value: ${n.value*8}`));else if(n.stat==="attack"&&n.value<0)if(c.isExhausted)s=-1,e.logic.push("Invalid Target (Already Exhausted)");else{const a=h.getEffectiveStats(c,I(c.id,u));s=a.attack*8-n.value*-5,e.logic.push(`Threat Reduction: ${a.attack*8}`)}else if(n.stat==="speed"&&n.value>0)if(c.isExhausted)s=-1,e.logic.push("Invalid (Exhausted)");else{const a=I(c.id,r),i=u.dronesOnBoard[a]||[],f=i.length>0?Math.max(...i.map(d=>h.getEffectiveStats(d,a).speed)):-1,l=h.getEffectiveStats(c,a);l.speed<=f&&l.speed+n.value>f?(s=60,e.logic.push("Interceptor Overcome Bonus: 60")):(s=20,e.logic.push("Utility Speed Bonus: 20"))}else c.isExhausted?(s=-1,e.logic.push("Invalid (Exhausted)")):(s=10,e.logic.push("Generic stat modification"));s>0&&(n.type==="permanent"&&(s*=1.5,e.logic.push("Permanent Mod x1.5")),t.effect.goAgain&&(s+=40,e.logic.push("Go Again Bonus: +40")),s-=t.cost*4,e.logic.push(`Cost: -${t.cost*4}`))}e.score=s;break}case"attack":{const{attacker:t,target:o,targetType:n}=e,c=h.getEffectiveStats(t,t.lane),a=Math.max(0,c.attack);if(n==="drone"){const i=h.getEffectiveStats(o,t.lane);if(s=i.class*10,e.logic.push(`(Target Class: ${i.class} * 10)`),c.class<i.class&&(s+=20,e.logic.push("Favorable Trade Bonus: 20")),o.isExhausted||(s+=10,e.logic.push("Ready Target Bonus: 10")),j.find(d=>d.name===t.name)?.abilities.some(d=>d.type==="PASSIVE"&&d.effect.type==="BONUS_DAMAGE_VS_SHIP")&&(s-=40,e.logic.push("Anti-Ship Penalty: -40")),t.damageType==="PIERCING"){const d=i.currentShields*8;s+=d,e.logic.push(`Piercing Bonus: ${d}`)}}else if(n==="section"){s=a*8,e.logic.push(`(Effective Attack: ${a} * 8)`);const i=m(o);if(i==="damaged"&&(s+=15,e.logic.push("Damaged Section Bonus: 15")),i==="critical"&&(s+=30,e.logic.push("Critical Section Bonus: 30")),o.allocatedShields===0?(s+=40,e.logic.push("No Shields Bonus: 40")):a>=o.allocatedShields&&(s+=35,e.logic.push("Shield Break Bonus: 35")),a>=3&&(s+=10,e.logic.push("High Attack Bonus: 10")),t.damageType==="PIERCING"){const f=o.allocatedShields*10;s+=f,e.logic.push(`Piercing Bonus: ${f}`)}}e.score=s;break}case"move":{const{drone:t,fromLane:o,toLane:n}=e;e.instigator=t.name,e.targetName=n;const c=C(o,r,u,L,m,h),a=C(n,r,u,L,m,h),i=JSON.parse(JSON.stringify(r)),f=i.dronesOnBoard[o].find(N=>N.id===t.id);f&&(i.dronesOnBoard[o]=i.dronesOnBoard[o].filter(N=>N.id!==t.id),i.dronesOnBoard[n].push(f));const l=C(o,i,u,L,m,h),B=C(n,i,u,L,m,h)-a,p=l-c,g=10;s=B+p-g,e.logic.push(`ToLane Impact: ${B.toFixed(0)}`),e.logic.push(`FromLane Impact: ${p.toFixed(0)}`),e.logic.push(`Move Cost: -${g}`);const T=parseInt(n.slice(-1))-1,P=M[T];if(P){const N=m(r.shipSections[P]);(N==="damaged"||N==="critical")&&a<0&&(s+=25,e.logic.push("Defensive Bonus: +25"))}const _=v[T];if(_){const F=j.find(A=>A.name===t.name)?.abilities.find(A=>A.type==="TRIGGERED"&&A.trigger==="ON_MOVE");if(F){let A=0;F.effects?.forEach(k=>{k.type==="PERMANENT_STAT_MOD"&&(k.mod.stat==="attack"&&(A+=k.mod.value*15),k.mod.stat==="speed"&&(A+=k.mod.value*10))}),s+=A,e.logic.push(`OnMove Bonus: +${A}`)}const V=m(u.shipSections[_]);a>0&&(V==="damaged"?(s+=20,e.logic.push("Offensive Bonus (Damaged Section): +20")):V==="critical"&&(s-=150,e.logic.push("Overkill Penalty (Critical Section): -150")))}e.score=s;break}}});const y=E.length>0?Math.max(...E.map(e=>e.score)):0;if(y<=0)return $({player:r.name,actionType:"PASS",source:"N/A",target:"N/A",outcome:"Passed during action phase."},"aiActionPass",E),{type:"pass"};const S=E.filter(e=>e.score>=y-20).filter(e=>e.score>0),b=S[Math.floor(Math.random()*S.length)];return b.isChosen=!0,{type:"action",payload:b,logContext:E}},q={handleOpponentTurn:Y,handleOpponentAction:W};export{q as aiBrain};
